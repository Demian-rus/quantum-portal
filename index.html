<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
  <title>–ö–≤–∞–Ω—Ç–æ–≤—ã–π –ø–æ—Ä—Ç–∞–ª</title>
 <style>
  /* ========================================================================== */
  /* 1. –ë–ê–ó–û–í–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï –ò –û–ë–©–ò–ï –°–¢–ò–õ–ò (MOBILE FIRST)                         */
  /* ========================================================================== */
  :root {
    --bg: #000000;
    --panel: #0d0d0d;
    --accent: #00ff33;
    --accent-hover: #00cc00;
    --text: #ffffff;
    --border: #00ff3344;
    --secondary: #888888;
  }

  * { margin:0; padding:0; box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
  body {
    background: var(--bg); 
    color: var(--text);
    font-family: 'Segoe UI', system-ui, sans-serif;
    min-height: 100vh; 
    display: flex; 
    flex-direction: column;
    align-items: center; 
    overflow-x: hidden;
  }

  /* ========================================================================== */
  /* 2. –ù–ê–í–ò–ì–ê–¶–ò–Ø –ò –®–ê–ü–ö–ê                                                       */
  /* ========================================================================== */
  nav {
    width: 100%; background: #0a0a0a; border-bottom: 1px solid var(--border);
    display: flex; justify-content: center; gap: 20px; padding: 12px;
  }
  .tab {
    background: transparent; color: #666; border: none; font-size: 15px;
    cursor: pointer; padding: 6px 12px; font-weight: bold; transition: 0.2s;
  }
  .tab.active {
    color: var(--accent); border-bottom: 2px solid var(--accent);
    text-shadow: 0 0 10px rgba(0, 255, 51, 0.5);
  }
  .tab:hover:not(.active) { color: #a0a0ff; }

  .header-area { padding: 20px 16px 15px; text-align: center; width: 100%; }
  h1 {
    font-size: 26px; color: var(--accent); letter-spacing: 3px;
    text-shadow: 0 0 20px #00ff33, 0 0 40px #00ff33, 0 0 60px #00aa00;
    margin-bottom: 5px; font-weight: 900;
  }
  .sub {
    color: var(--secondary); font-size: 12px; letter-spacing: 1px;
    text-transform: uppercase;
  }

  /* ========================================================================== */
  /* 3. –ö–ù–û–ü–ö–ò –£–ü–†–ê–í–õ–ï–ù–ò–Ø –ò –ò–ù–§–û-–ü–ê–ù–ï–õ–ò                                         */
  /* ========================================================================== */
  .controls {
    display:flex; gap:10px; flex-wrap:wrap; justify-content:center;
    margin-bottom:20px; padding: 0 16px; max-width: 1000px;
  }
  .control-group {
    display: flex; gap: 10px; background: rgba(0, 255, 51, 0.05);
    padding: 8px; border-radius: 2px; border: 1px solid var(--border);
  }
  select, button {
    background: var(--panel); border: 1px solid var(--border); color: var(--text);
    padding: 8px 16px; border-radius: 2px; font-size: 14px;
    cursor: pointer; transition: 0.2s; outline: none;
  }
  select:hover, button:hover {
    border-color: var(--accent); box-shadow: 0 0 10px rgba(0, 255, 51, 0.3);
  }
  button.primary {
    background: rgba(0, 255, 51, 0.1); color: var(--accent); font-weight: bold;
    border-color: rgba(0, 255, 51, 0.6);
  }
  button.primary:hover {
    background: rgba(0, 255, 51, 0.2); box-shadow: 0 0 15px rgba(0, 255, 51, 0.4);
  }
  button.action { color: var(--accent); border-color: rgba(0, 255, 51, 0.5); }
  button.danger { color: #ff6b35; border-color: rgba(255,107,53,0.5); }
  .stat-line {
    width: 100%; text-align: center; font-size: 13px;
    color: #555588; margin-bottom: 15px;
  }

  #active-q-panel, #phil-active-panel, #su-active-panel, #qnt-active-panel {
    background: var(--panel); border: 1px solid var(--border);
    box-shadow: 0 5px 20px rgba(0,0,0,0.4);
    border-radius: 10px; padding: 15px 20px; margin-bottom: 20px; min-height: 52px;
    display: flex; align-items: center; justify-content: center; text-align: center;
    font-weight: bold; font-size: 16px; width: 100%; max-width: 900px;
  }
  #active-q-panel { color: #ff6b35; }
  #phil-active-panel { color: #a855f7; font-size: 15px; }
  #su-active-panel { color: #fbbf24; font-size: 15px; max-width: 500px; }
  #qnt-active-panel { color: #06f3ff; font-size: 15px; }

  /* ========================================================================== */
  /* 4. –û–°–ù–û–í–ù–û–ô –ö–û–ù–¢–ï–ô–ù–ï–† –ò CANVAS                                             */
  /* ========================================================================== */
  .main-container {
    display: flex; flex-direction: row; align-items: flex-start; justify-content: center;
    width: 100%; max-width: 1300px; padding: 0 16px 30px; gap: 20px; position: relative;
  }
  .game-section { display: none; width: 100%; flex-direction: column; align-items: center; }
  .game-section.active { display: flex; }
  .game-area {
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    flex: 1; min-width: 0; transition: 0.3s;
  }

  canvas {
    border-radius: 12px; display: block; max-width: 100%;
    cursor: pointer; box-shadow: 0 0 30px rgba(0,0,0,0.5);
  }
  #cv, #cvSudoku { touch-action: manipulation; }
  #cvPhil { touch-action: none; }

  .placeholder-box {
    border: 2px dashed #333; border-radius: 16px; width: 100%; max-width: 800px;
    height: 300px; display: flex; align-items: center; justify-content: center;
    flex-direction: column; gap: 10px; margin-top: 40px;
  }
  .placeholder-box h2 { color: #555; font-size: 24px; }
  .placeholder-box p { color: #444; }

  /* ========================================================================== */
  /* 5. –°–ê–ô–î–ë–ê–†–´ (–ö–†–û–°–°–í–û–†–î –ò –§–ò–õ–í–û–†–î) - –ë–ê–ó–ê (–ú–û–ë–ò–õ–ö–ê/–ü–õ–ê–ù–®–ï–¢)                  */
  /* ========================================================================== */
  #sidebar, #philSidebar {
    width: 100%;
    max-width: 600px;
    background: rgba(11, 11, 30, 0.95);
    border: 1px solid var(--border);
    border-radius: 12px;
    display: flex;
    flex-direction: column;
    overflow: hidden;

    height: 280px;
    min-height: 0;

    position: relative;
    top: 0;
    transition: width 0.3s ease, border-radius 0.3s ease, top 0.3s ease;
  }

  .sb-header {
    padding: 12px 14px; border-bottom: 1px solid var(--border);
    display: flex; justify-content: space-between; align-items: center;
    height: 50px; cursor: pointer;
  }
  .sb-title {
    color: var(--accent); font-size: 15px; letter-spacing: 1px;
    white-space: nowrap; transition: opacity 0.2s;
  }
  .toggle-btn {
    background: none; border: none; color: var(--accent); font-size: 20px;
    cursor: pointer; padding: 0; width: 30px; height: 30px; transition: 0.3s;
    display: flex; align-items: center; justify-content: center; border-radius: 4px;
  }
  .toggle-btn:hover { background: rgba(0,212,255,0.1); }

  .sb-content {
    padding: 20px; overflow-y: auto; flex: 1; transition: opacity 0.3s;
    width: 100%; scrollbar-width: thin; scrollbar-color: var(--border) transparent;
  }
  .sb-content::-webkit-scrollbar { width: 6px; }
  .sb-content::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }

  .clues-section { margin-bottom: 25px; }
  .clues-section h3 {
    color: #a855f7; font-size: 13px; margin-bottom: 12px;
    border-bottom: 1px solid #333; padding-bottom: 5px; letter-spacing: 1px;
  }
  .clue-item { font-size: 13px; color: #bbb; margin-bottom: 10px; line-height: 1.4; transition: 0.2s; }
  .clue-item b { color: #fbbf24; }
  .clue-item.active {
    color: #fff; background: rgba(0,212,255,0.1); padding: 6px 8px;
    border-radius: 6px; border-left: 3px solid var(--accent); margin-left: -11px;
  }

  .phw-item {
    font-size: 13px; color: #bbb; margin-bottom: 10px;
    line-height: 1.4; padding: 6px 8px; border-radius: 6px;
    border-left: 3px solid transparent;
  }
  .phw-item b { color:#fbbf24; }
  .phw-item.found {
    color: #8affc1; background: rgba(74, 222, 128, 0.10);
    border-left-color: rgba(74, 222, 128, 0.75); text-decoration: line-through;
  }

  /* ========================================================================== */
  /* 6. –ò–ì–†–û–í–´–ï –ú–û–î–£–õ–ò: –°–£–î–û–ö–£, –ö–í–ê–ù–¢, –ö–õ–ê–í–ò–ê–¢–£–†–´                               */
  /* ========================================================================== */
  .su-numpad {
    display: flex; gap: 5px; margin-top: 15px;
    justify-content: center; flex-wrap: wrap; max-width: 400px;
  }
  .su-numpad button {
    width: 36px; height: 40px; font-size: 18px; font-weight: bold;
    background: #1e1e3f; color: #fff; border: 1px solid #444;
    border-radius: 6px; cursor: pointer; padding: 0;
  }
  .su-numpad button:hover { background: var(--accent); border-color: var(--accent); }
  .su-numpad button.clr { color: #ff6b35; border-color: #ff6b35; }

  .qnt-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(50px, 1fr));
    gap: 8px; margin-bottom: 20px;
    width: fit-content; margin-left: auto; margin-right: auto;
  }
  .qnt-letter {
    width: 50px; height: 50px; border: 2px solid #00d4ff; border-radius: 6px;
    display: flex; align-items: center; justify-content: center;
    font-weight: bold; font-size: 20px; background: #0a0a18; color: #fff;
    transition: 0.2s;
  }
  .qnt-letter.correct { background: #4ade80; border-color: #4ade80; color: #000; }
  .qnt-letter.present { background: #fbbf24; border-color: #fbbf24; color: #000; }
  .qnt-letter.absent { background: #333; border-color: #666; color: #aaa; }

  .qnt-keyboard {
    display: flex; flex-direction: column; gap: 6px;
    max-width: 480px; margin: 0 auto 15px;
  }
  .qnt-key-row { display: flex; gap: 4px; justify-content: center; }
  .qnt-key {
    padding: 8px 10px; background: #1a1a38; border: 1px solid #333;
    color: #fff; border-radius: 4px; cursor: pointer;
    font-size: 13px; font-weight: bold; transition: 0.1s; min-width: 28px;
  }
  .qnt-key:hover { background: #2a2a60; }
  .qnt-key.correct { background: #4ade80; border-color: #4ade80; color: #000; }
  .qnt-key.present { background: #fbbf24; border-color: #fbbf24; color: #000; }
  .qnt-key.absent { background: #333; border-color: #666; }

  .qnt-stats {
    display: flex; gap: 20px; justify-content: center;
    margin-top: 15px; padding: 15px;
    background: rgba(0,212,255,0.05); border-radius: 6px; font-size: 14px;
  }
  .qnt-stat-item { text-align: center; }
  .qnt-stat-value { font-size: 20px; font-weight: bold; color: #00d4ff; }

  #cw-keypad {
    display: flex; flex-direction: column; align-items: center; gap: 5px;
    margin-top: 10px; margin-bottom: 10px; width: 100%; max-width: 420px;
    padding: 10px 6px; background: rgba(0, 0, 0, 0.5);
    border: 1px solid var(--border); border-radius: 2px; flex-shrink: 0;
  }
  #cw-keypad.visible { display: flex; }
  .cw-row { display: flex; gap: 2px; justify-content: center; width: 100%; }
  .cw-row button {
    flex: 1 1 0; min-width: 0; height: 40px; font-size: 13px;
    font-weight: bold; background: #1a1a38; color: #d0d8ff;
    border: 1px solid #333355; border-radius: 6px; cursor: pointer;
    padding: 0; transition: 0.1s;
  }
  .cw-row button:active {
    background: var(--accent); color: #000; border-color: var(--accent);
    transform: scale(0.92);
  }
  .cw-del {
    flex: 1.5 1 0 !important; color: #ff6b35 !important;
    border-color: rgba(255,107,53,0.4) !important;
  }

  /* ========================================================================== */
  /* 7. –ú–û–ë–ò–õ–¨–ù–´–ï –£–°–¢–†–û–ô–°–¢–í–ê (< 650px)                                          */
  /* ========================================================================== */
  @media (max-width: 650px) {
    h1 { font-size: 18px; letter-spacing: 1px; }
    .sub { display: none; }
    .header-area { padding: 10px 8px 8px; }
    nav { gap: 6px; padding: 8px; }
    .tab { font-size: 13px; padding: 5px 8px; }
    .controls { gap: 6px; padding: 0 8px; }
    .control-group { gap: 6px; padding: 6px; flex-wrap: wrap; justify-content: center; }
    select, button { font-size: 12px; padding: 7px 10px; }
    .main-container { padding: 0 8px 20px; gap: 10px; flex-direction: column; align-items: center; }

    #active-q-panel, #phil-active-panel, #su-active-panel {
      font-size: 12px; padding: 8px 10px; margin-bottom: 10px;
      min-height: 40px; line-height: 1.3; max-width: 100%;
    }
    .su-numpad { gap: 6px; margin-top: 12px; }
    .su-numpad button {
      width: 38px; height: 44px; font-size: 20px;
    }
    .qnt-grid { grid-template-columns: repeat(5, 1fr); gap: 6px; }
    .qnt-letter { width: 40px; height: 40px; font-size: 16px; }
    .qnt-key { min-width: 24px; font-size: 12px; padding: 6px 8px; }

    #sidebar, #philSidebar { height: 240px; max-width: 600px; position: relative; top: 0; }
    #sidebar.collapsed, #philSidebar.collapsed { height: 44px !important; }
    #cw-keypad { display: flex !important; margin-bottom: 10px; }
  }

  /* –ù–∞ –¥–µ—Å–∫—Ç–æ–ø–µ —ç–∫—Ä–∞–Ω–Ω–∞—è –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –∫—Ä–æ—Å—Å–≤–æ—Ä–¥–∞ —Å–∫—Ä—ã—Ç–∞ */
  @media (min-width: 769px) {
    #cw-keypad { display: none !important; }
  }

  /* ========================================================================== */
  /* 8. –î–ï–°–ö–¢–û–ü–´ (>= 1280px) ‚Äî –°–ê–ô–î–ë–ê–† –°–ü–†–ê–í–ê, –í–´–°–û–¢–ê –ß–ï–†–ï–ó JS                  */
  /* ========================================================================== */
  @media (min-width: 1280px) {
  .main-container { position: relative; justify-content: center; }
  .game-area { width: 100%; }

  /* –°–∞–π–¥–±–∞—Ä —Å–ø—Ä–∞–≤–∞, –≤—ã—Å–æ—Ç—É –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ –Ω–µ —Ñ–∏–∫—Å–∏—Ä—É–µ–º */
  #sidebar, #philSidebar {
    position: absolute !important;
    right: 20px;
    top: 72px !important;
    width: 320px !important;
    height: auto;
    min-height: 0;
  }

  /* –û–ì–†–ê–ù–ò–ß–ï–ù–ò–ï –í–´–°–û–¢–´ –¢–û–õ–¨–ö–û –î–õ–Ø –°–ü–ò–°–ö–ê –í–ù–£–¢–†–ò (–†–ê–ó–í–Å–†–ù–£–¢–û) */
  #sidebar:not(.collapsed) .sb-content,
  #philSidebar:not(.collapsed) .sb-content {
    max-height: calc(100vh - 400px); /* ‚Üê –∑–¥–µ—Å—å —Ç—ã –ø–æ–¥–±–∏—Ä–∞–µ—à—å —á–∏—Å–ª–æ */
    overflow-y: auto;
  }

  /* –ö—Ä—É–∂–æ–∫ –ø—Ä–∏ —Å–≤–æ—Ä–∞—á–∏–≤–∞–Ω–∏–∏ */
  #sidebar.collapsed, #philSidebar.collapsed {
    width: 44px !important;
    height: 44px !important;
    min-height: 44px !important;
    max-height: 44px !important;
    border-radius: 50% !important;
    cursor: pointer;
    background: var(--panel) !important;
    border: 2px solid var(--accent) !important;
    box-shadow: 0 0 20px rgba(0, 255, 51, 0.25);
    overflow: hidden; /* —á—Ç–æ–±—ã –≤ –∫—Ä—É–∂–∫–µ –Ω–µ –±—ã–ª–æ –ø–æ–ª–æ—Å—ã –ø—Ä–æ–∫—Ä—É—Ç–∫–∏ */
  }

  #sidebar.collapsed .sb-header, #philSidebar.collapsed .sb-header {
    height: 100%; padding: 0; border: none; justify-content: center;
  }

  #sidebar.collapsed .toggle-btn, #philSidebar.collapsed .toggle-btn {
    width: 100% !important;
    height: 100% !important;
    position: absolute !important;
    top: 0 !important;
    left: 0 !important;
    transform: none !important;
    color: transparent;
    margin: 0 !important;
    padding: 0 !important;
  }

  #sidebar.collapsed .toggle-btn::after, #philSidebar.collapsed .toggle-btn::after {
    content: "‚ò∞";
    color: var(--accent);
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    font-size: 20px;
    line-height: 1;
  }
}

  /* –ü—Ä—è—á–µ–º –∫–æ–Ω—Ç–µ–Ω—Ç –≤ —Å–≤–µ—Ä–Ω—É—Ç–æ–º –≤–∏–¥–µ (–≥–ª–æ–±–∞–ª—å–Ω–æ) */
  #sidebar.collapsed .sb-content, #philSidebar.collapsed .sb-content,
  #sidebar.collapsed .sb-title, #philSidebar.collapsed .sb-title {
    opacity: 0 !important; pointer-events: none !important; overflow: hidden !important;
  }

  .popup-backdrop {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}

.popup {
  background: #0b0b13;
  border: 1px solid var(--border);
  border-radius: 10px;
  padding: 20px;
  max-width: 320px;
  width: 90%;
  text-align: center;
  box-shadow: 0 0 30px rgba(0,0,0,0.7);
}

.popup-actions {
  margin-top: 15px;
  display: flex;
  gap: 10px;
  justify-content: center;
}

</style>

</head>
<body>
    <div id="hidden-input" style="display:none;"></div>
    <div id="qp-popup" style="display:none" class="popup-backdrop">
  <div class="popup">
    <p id="qp-popup-text"></p>
    <div class="popup-actions">
      <button id="qp-popup-ok" class="primary">–î–∞</button>
      <button id="qp-popup-cancel" class="danger">–ù–µ—Ç</button>
    </div>
  </div>
</div>


  <nav>
    <button class="tab active" onclick="switchTab('crossword')">–ö—Ä–æ—Å—Å–≤–æ—Ä–¥</button>
    <button class="tab" onclick="switchTab('philword')">–§–∏–ª–≤–æ—Ä–¥</button>
    <button class="tab" onclick="switchTab('sudoku')">–°—É–¥–æ–∫—É</button>
    <button class="tab" onclick="switchTab('quant')">–ö–≤–∞–Ω—Ç</button>
  </nav>

  <div class="header-area">
    <h1>‚¨° –ö–í–ê–ù–¢–û–í–´–ô –ü–û–†–¢–ê–õ</h1>
    <p class="sub" id="sub-title">–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π —Ä–µ–∂–∏–º –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏</p>
  </div>

<div id="sec-crossword" class="game-section active">
    
    <div class="controls">
      <div class="control-group">
        <select id="sel-theme">
          <option value="—Ñ–∏–∑–∏–∫–∞">–§–∏–∑–∏–∫–∞</option>
          <option value="–º–∞—Ç–µ–º–∞—Ç–∏–∫–∞">–ú–∞—Ç–µ–º–∞—Ç–∏–∫–∞</option>
          <option value="—Ñ–∏–∑–º–∞—Ç">–§–∏–∑–ú–∞—Ç (–ú–∏–∫—Å)</option>
        </select>
        <select id="sel-level">
          <option value="–ª–µ–≥–∫–∏–π">–õ—ë–≥–∫–∏–π</option>
          <option value="—Å—Ä–µ–¥–Ω–∏–π">–°—Ä–µ–¥–Ω–∏–π</option>
          <option value="—Å–ª–æ–∂–Ω—ã–π">–°–ª–æ–∂–Ω—ã–π</option>
        </select>
      </div>
      <div class="control-group">
        <button class="primary" onclick="onGenerate()">‚ü≥ –°–æ–∑–¥–∞—Ç—å</button>
        <button class="action" onclick="onToggleAnswers()" id="btn-answ">üëÅ –û—Ç–≤–µ—Ç—ã</button>
        <button class="danger" onclick="usedWordsHistory.clear(); document.getElementById('stat').textContent='‚ôª –ò—Å—Ç–æ—Ä–∏—è —Å–±—Ä–æ—à–µ–Ω–∞';">‚ôª –°–±—Ä–æ—Å</button>
      </div>
    </div>

    <div class="stat-line" id="stat">–ì–æ—Ç–æ–≤ –∫ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏</div>

    <div class="main-container">
      <div class="game-area">
        <div id="active-q-panel">–°–≥–µ–Ω–µ—Ä–∏—Ä—É–π—Ç–µ –∫—Ä–æ—Å—Å–≤–æ—Ä–¥ –∏ –≤—ã–±–µ—Ä–∏—Ç–µ –∫–ª–µ—Ç–∫—É</div>
        <canvas id="cv"></canvas>
        <div id="cw-keypad">
  <div class="cw-row">
    <button onclick="handleInput('–ô')">–ô</button>
    <button onclick="handleInput('–¶')">–¶</button>
    <button onclick="handleInput('–£')">–£</button>
    <button onclick="handleInput('–ö')">–ö</button>
    <button onclick="handleInput('–ï')">–ï</button>
    <button onclick="handleInput('–ù')">–ù</button>
    <button onclick="handleInput('–ì')">–ì</button>
    <button onclick="handleInput('–®')">–®</button>
    <button onclick="handleInput('–©')">–©</button>
    <button onclick="handleInput('–ó')">–ó</button>
    <button onclick="handleInput('–•')">–•</button>
    <button onclick="handleInput('–™')">–™</button>
  </div>
  <div class="cw-row">
    <button onclick="handleInput('–§')">–§</button>
    <button onclick="handleInput('–´')">–´</button>
    <button onclick="handleInput('–í')">–í</button>
    <button onclick="handleInput('–ê')">–ê</button>
    <button onclick="handleInput('–ü')">–ü</button>
    <button onclick="handleInput('–†')">–†</button>
    <button onclick="handleInput('–û')">–û</button>
    <button onclick="handleInput('–õ')">–õ</button>
    <button onclick="handleInput('–î')">–î</button>
    <button onclick="handleInput('–ñ')">–ñ</button>
    <button onclick="handleInput('–≠')">–≠</button>
  </div>
  <div class="cw-row">
    <button onclick="handleInput('–Ø')">–Ø</button>
    <button onclick="handleInput('–ß')">–ß</button>
    <button onclick="handleInput('–°')">–°</button>
    <button onclick="handleInput('–ú')">–ú</button>
    <button onclick="handleInput('–ò')">–ò</button>
    <button onclick="handleInput('–¢')">–¢</button>
    <button onclick="handleInput('–¨')">–¨</button>
    <button onclick="handleInput('–ë')">–ë</button>
    <button onclick="handleInput('–Æ')">–Æ</button>
    <button onclick="handleInput('–Å')">–Å</button>
    <button onclick="handleInput('Backspace')" class="cw-del">‚å´</button>
  </div>
</div>

      </div>

      <div id="sidebar" class="collapsed" onclick="if(this.classList.contains('collapsed')) toggleSidebar()">
        <div class="sb-header">
          <h2 class="sb-title">–°–ü–ò–°–û–ö –í–û–ü–†–û–°–û–í</h2>
          <button class="toggle-btn" onclick="toggleSidebar(event)">‚ùØ</button>
        </div>
        <div class="sb-content" id="cluesList"></div>
      </div>
    </div>
  </div>

<div id="sec-philword" class="game-section">
  <div class="controls">
    <div class="control-group">
      <select id="sel-theme-ph">
        <option value="—Ñ–∏–∑–∏–∫–∞">–§–∏–∑–∏–∫–∞</option>
        <option value="–º–∞—Ç–µ–º–∞—Ç–∏–∫–∞">–ú–∞—Ç–µ–º–∞—Ç–∏–∫–∞</option>
        <option value="—Ñ–∏–∑–º–∞—Ç">–§–∏–∑–ú–∞—Ç (–ú–∏–∫—Å)</option>
      </select>
      <select id="sel-level-ph">
        <option value="–ª–µ–≥–∫–∏–π">–õ—ë–≥–∫–∏–π</option>
        <option value="—Å—Ä–µ–¥–Ω–∏–π">–°—Ä–µ–¥–Ω–∏–π</option>
        <option value="—Å–ª–æ–∂–Ω—ã–π">–°–ª–æ–∂–Ω—ã–π</option>
      </select>
      <select id="sel-size-ph">
        <option value="12">–°–µ—Ç–∫–∞ 12√ó12</option>
        <option value="14" selected>–°–µ—Ç–∫–∞ 14√ó14</option>
        <option value="16">–°–µ—Ç–∫–∞ 16√ó16</option>
      </select>
    </div>

    <div class="control-group">
      <button class="primary" onclick="philGenerate()">‚ü≥ –°–æ–∑–¥–∞—Ç—å</button>
      <button class="action" onclick="philToggleAnswers()" id="btn-ph-answ">üëÅ –û—Ç–≤–µ—Ç—ã</button>
      <button class="danger" onclick="philUsedWordsHistory.clear(); document.getElementById('phil-stat').textContent='‚ôª –ò—Å—Ç–æ—Ä–∏—è —Ñ–∏–ª–≤–æ—Ä–¥–∞ —Å–±—Ä–æ—à–µ–Ω–∞';">‚ôª –°–±—Ä–æ—Å</button>
    </div>
  </div>

  <div class="stat-line" id="phil-stat">–ì–æ—Ç–æ–≤ –∫ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ñ–∏–ª–≤–æ—Ä–¥–∞</div>

  <div class="main-container">
    <div class="game-area">
      <div id="phil-active-panel">–ù–∞–∂–º–∏—Ç–µ ¬´–°–æ–∑–¥–∞—Ç—å¬ª, –∑–∞—Ç–µ–º –≤—ã–¥–µ–ª—è–π—Ç–µ —Å–ª–æ–≤–∞ –ø—Ä–æ—Ç—è–∂–∫–æ–π –ø–æ –±—É–∫–≤–∞–º</div>
      <canvas id="cvPhil"></canvas>
    </div>

        <div id="philSidebar">
      <div class="sb-header" onclick="toggleSidebar(event)">
        <h2 class="sb-title" style="opacity:1">–°–õ–û–í–ê –î–õ–Ø –ü–û–ò–°–ö–ê</h2>
        <button class="toggle-btn">‚ùØ</button>
      </div>
      <div class="sb-content" id="philWords"></div>
    </div>
  </div>
</div>

  <div id="sec-sudoku" class="game-section">
  <div class="controls">
    <div class="control-group">
      <select id="sel-diff-su">
        <option value="easy">–õ—ë–≥–∫–∏–π</option>
        <option value="medium" selected>–°—Ä–µ–¥–Ω–∏–π</option>
        <option value="hard">–°–ª–æ–∂–Ω—ã–π</option>
        <option value="insane">–ë–µ–∑—É–º–Ω—ã–π</option>
      </select>
    </div>

    <div class="control-group">
      <button class="primary" onclick="sudokuGenerate()">‚ü≥ –°–æ–∑–¥–∞—Ç—å</button>
      <button class="action" onclick="sudokuCheck()" id="btn-su-check">‚úÖ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å</button>
      <button class="danger" onclick="sudokuReset()">‚ôª –°–±—Ä–æ—Å</button>
    </div>
  </div>

  <div class="stat-line" id="su-stat">–ì–æ—Ç–æ–≤ –∫ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Å—É–¥–æ–∫—É</div>

  <div class="main-container">
    <div class="game-area">
      <div id="su-active-panel">–í—ã–±–µ—Ä–∏—Ç–µ –∫–ª–µ—Ç–∫—É –∏ –≤–≤–µ–¥–∏—Ç–µ —Ü–∏—Ñ—Ä—É (1-9)</div>
      <canvas id="cvSudoku"></canvas>
      
      <!-- –ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö -->
      <div class="su-numpad">
        <button onclick="sudokuInput(1)">1</button>
        <button onclick="sudokuInput(2)">2</button>
        <button onclick="sudokuInput(3)">3</button>
        <button onclick="sudokuInput(4)">4</button>
        <button onclick="sudokuInput(5)">5</button>
        <button onclick="sudokuInput(6)">6</button>
        <button onclick="sudokuInput(7)">7</button>
        <button onclick="sudokuInput(8)">8</button>
        <button onclick="sudokuInput(9)">9</button>
        <button onclick="sudokuInput(0)" class="clr">‚å´</button>
      </div>
          </div>
    </div>
  </div>

<div id="sec-quant" class="game-section">
  <div class="controls">
    <div class="control-group">
      <select id="sel-theme-qnt">
        <option value="—Ñ–∏–∑–∏–∫–∞">–§–∏–∑–∏–∫–∞</option>
        <option value="–º–∞—Ç–µ–º–∞—Ç–∏–∫–∞">–ú–∞—Ç–µ–º–∞—Ç–∏–∫–∞</option>
        <option value="—Ñ–∏–∑–º–∞—Ç">–§–∏–∑–ú–∞—Ç (–ú–∏–∫—Å)</option>
      </select>
      <select id="sel-level-qnt">
        <option value="–ª–µ–≥–∫–∏–π">–õ—ë–≥–∫–∏–π</option>
        <option value="—Å—Ä–µ–¥–Ω–∏–π">–°—Ä–µ–¥–Ω–∏–π</option>
        <option value="—Å–ª–æ–∂–Ω—ã–π">–°–ª–æ–∂–Ω—ã–π</option>
      </select>
    </div>
    <div class="control-group">
      <button class="primary" onclick="quantGenerate()">‚ü≥ –ù–æ–≤–æ–µ —Å–ª–æ–≤–æ</button>
      <button class="action" onclick="quantShowHint()" id="btn-qnt-hint">üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞</button>
      <button class="danger" onclick="quantReset()">‚ôª –°–±—Ä–æ—Å</button>
    </div>
  </div>
  <div class="stat-line" id="qnt-stat">–ì–æ—Ç–æ–≤ –∫ –∏–≥—Ä–µ –ö–≤–∞–Ω—Ç</div>
  <div class="main-container" style="flex-direction: column; align-items: center;">
    <div class="game-area">
      <div id="qnt-active-panel">–£–≥–∞–¥–∞–π—Ç–µ —Å–ª–æ–≤–æ (6 –ø–æ–ø—ã—Ç–æ–∫)</div>
      <div class="qnt-grid" id="qntGrid"></div>
      <div class="qnt-keyboard" id="qntKeyboard"></div>
      <div class="qnt-stats">
        <div class="qnt-stat-item">
          <div class="qnt-stat-value" id="qnt-attempts">6</div>
          <div>–ü–æ–ø—ã—Ç–æ–∫</div>
        </div>
        <div class="qnt-stat-item">
          <div class="qnt-stat-value" id="qnt-wins">0</div>
          <div>–ü–æ–±–µ–¥</div>
        </div>
      </div>
    </div>
  </div>
</div>
<script src="db.js"></script>
  <script>
    
// ==========================================
// üì¶ STORAGE MANAGER
// ==========================================
const Storage = {
    key: 'QP_Data_v1',
    load() {
        try { 
            return JSON.parse(localStorage.getItem(this.key)) || { stats: {}, history: { words: [] } };
        } catch { 
            return { stats: {}, history: { words: [] } };
        }
    },
    save(data) { localStorage.setItem(this.key, JSON.stringify(data)); },
    addWin(game) {
        let data = this.load();
        if (!data.stats[game]) data.stats[game] = 0;
        data.stats[game]++;
        this.save(data);
    },
    addWord(word) {
        let data = this.load();
        if (!data.history.words) data.history.words = [];
        data.history.words.push(word);
        if (data.history.words.length > 100) data.history.words.shift(); 
        this.save(data);
    }
};

const winMarked = { crossword:false, philword:false, sudoku:false, quant:false };

function markWin(game){
    if (winMarked[game]) return;
    winMarked[game] = true;
    Storage.addWin(game);
}

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –∏—Å—Ç–æ—Ä–∏—é –∏–∑ –ø–∞–º—è—Ç–∏ –±—Ä–∞—É–∑–µ—Ä–∞
const usedWordsHistory = new Set(Storage.load().history.words);

// –ü–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª—è–µ–º –º–µ—Ç–æ–¥ add —É Set
const originalAdd = usedWordsHistory.add.bind(usedWordsHistory);
usedWordsHistory.add = function(word) {
    originalAdd(word);
    Storage.addWord(word);
    return this;
};

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏—Å—Ç–æ—Ä–∏–∏ –¥–ª—è —Ñ–∏–ª–≤–æ—Ä–¥–∞
let philUsedWordsHistory = new Set(Storage.load().history.words); 
philUsedWordsHistory.add = usedWordsHistory.add; 

function showConfirmPopup(text, onOk, onCancel) {
  const wrap = document.getElementById('qp-popup');
  if (!wrap) { onOk && onOk(); return; }

  const textEl = document.getElementById('qp-popup-text');
  const ok = document.getElementById('qp-popup-ok');
  const cancel = document.getElementById('qp-popup-cancel');

  textEl.textContent = text;

  const clear = () => {
    ok.onclick = cancel.onclick = null;
    wrap.style.display = 'none';
  };

  ok.onclick = () => { clear(); onOk && onOk(); };
  cancel.onclick = () => { clear(); onCancel && onCancel(); };

  wrap.style.display = 'flex';
}

// ==========================================
const N = 35;

  let userGrid = [];
  let activeWord = null;
  let activeR = -1;
  let activeC = -1;
  let isSolved = false;
  let showAnswers = false;

  // ================= –ü–û–ü–†–û–ì–†–ï–°–°–ù–´–ï –ß–ï–ö–ï–†–´ =================

// –ö—Ä–æ—Å—Å–≤–æ—Ä–¥: –µ—Å—Ç—å –≤–≤–µ–¥—ë–Ω–Ω—ã–µ –±—É–∫–≤—ã
function crosswordHasProgress() {
  if (!userGrid || !userGrid.length) return false;
  for (let r = 0; r < N; r++) {
    for (let c = 0; c < N; c++) {
      if (userGrid[r][c]) return true;
    }
  }
  return false;
}

// –§–∏–ª–≤–æ—Ä–¥: –µ—Å—Ç—å —Å–µ—Ç–∫–∞ –∏ –Ω–∞–π–¥–µ–Ω—ã —Å–ª–æ–≤–∞
function philHasProgress() {
  return phGrid && phGrid.length > 0 && (phFound.size > 0);
}

// –°—É–¥–æ–∫—É: –µ—Å—Ç—å —Å–µ—Ç–∫–∞ –∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —á—Ç–æ‚Äë—Ç–æ –º–µ–Ω—è–ª
function sudokuHasProgress() {
  if (!suGrid || !suGrid.length || !suSolution || !suSolution.length) return false;
  for (let r = 0; r < 9; r++) {
    for (let c = 0; c < 9; c++) {
      if (!suFixed[r][c] && suGrid[r][c] !== 0) return true;
    }
  }
  return false;
}

// –ö–≤–∞–Ω—Ç: –∑–∞–≥–∞–¥–∞–Ω–æ —Å–ª–æ–≤–æ –∏ –±—ã–ª–∏ –ø–æ–ø—ã—Ç–∫–∏
function quantHasProgress() {
  return !!quantCurrentWord && (quantAttempts < 6 || quantCurrentGuess.length > 0);
}

  function switchTab(id) {
    document.querySelectorAll('.tab').forEach(b => b.classList.remove('active'));
    document.querySelectorAll('.game-section').forEach(s => s.classList.remove('active'));
    event.target.classList.add('active');
    document.getElementById('sec-' + id).classList.add('active');
    
    const titles = {
      'crossword': '–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π —Ä–µ–∂–∏–º –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫—Ä–æ—Å—Å–≤–æ—Ä–¥–æ–≤',
      'philword': '–ü–æ–∏—Å–∫ —Å–ª–æ–≤ (—Å–∫–æ—Ä–æ)',
      'sudoku': '–ö–ª–∞—Å—Å–∏—á–µ—Å–∫–æ–µ —Å—É–¥–æ–∫—É (—Å–∫–æ—Ä–æ)',
      'quant': '–ö–≤–∞–Ω—Ç - —É–≥–∞–¥–∞–π —Ç–µ—Ä–º–∏–Ω–æ–ª–æ–≥–∏—é'
    };
    document.getElementById('sub-title').textContent = titles[id];


    // —á—Ç–æ–±—ã –≤–≤–æ–¥ –±—É–∫–≤ –Ω–µ –ø—Ä–æ–¥–æ–ª–∂–∞–ª –ª–µ—Ç–µ—Ç—å –≤ —Å–∫—Ä—ã—Ç—ã–π –∫—Ä–æ—Å—Å–≤–æ—Ä–¥
    if (id !== 'crossword') { activeWord = null; activeR = -1; activeC = -1; }


    // –ª–µ–Ω–∏–≤—ã–π —Å—Ç–∞—Ä—Ç —Ñ–∏–ª–≤–æ—Ä–¥–∞
    if (id === 'philword') {
    philInitOnce();
    if (!phGrid || !phGrid.length) philGenerate();
    }


    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å—É–¥–æ–∫—É
    if(id === 'sudoku') {
    sudokuInitOnce();
    if(!suGrid.length) sudokuGenerate();
    }

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ö–≤–∞–Ω—Ç–∞
    if(id === 'quant') {
    if (!quantCurrentWord) quantGenerate();
    }
  }



function toggleSidebar(e) {
  if (e) e.stopPropagation();

  let activeSidebar = null;
  if (document.getElementById('sec-crossword')?.classList.contains('active')) {
    activeSidebar = document.getElementById('sidebar');
  } else if (document.getElementById('sec-philword')?.classList.contains('active')) {
    activeSidebar = document.getElementById('philSidebar');
  }

  if (activeSidebar) {
    activeSidebar.classList.toggle('collapsed');
    requestAnimationFrame(() => window.syncSidebars?.());
  }
}



  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  //  –ú–ê–°–ö–ò –î–õ–Ø –§–ò–ì–£–† 
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  function makeMaskFree() { 
  const centerR = Math.floor(N / 2);  // 17
  const centerC = Math.floor(N / 2);  // 17
  const radius = 10; // 20√ó20 –∫–≤–∞–¥—Ä–∞—Ç
  
  return Array.from({length:N}, (_, r) => Array.from({length:N}, (_, c) => {
    return Math.abs(r - centerR) <= radius && Math.abs(c - centerC) <= radius;
  }));
}

  function makeMaskSquare() {
    const S = 3, S2 = 7, E = N - 4, E2 = N - 8, M = Math.floor(N/2);
    return Array.from({length:N}, (_, r) => Array.from({length:N}, (_, c) => {
      const isTop = (r >= S && r <= S2) && (c >= S && c <= E);
      const isBot = (r >= E2 && r <= E) && (c >= S && c <= E);
      const isLef = (c >= S && c <= S2) && (r >= S && r <= E);
      const isRig = (c >= E2 && c <= E) && (r >= S && r <= E);
      const isCrossH = Math.abs(r - M) <= 1 && (c >= S && c <= E);
      const isCrossV = Math.abs(c - M) <= 1 && (r >= S && r <= E);
      return isTop || isBot || isLef || isRig || isCrossH || isCrossV;
    }));
  }

  function makeMaskDiamond() {
    const cx = Math.floor(N/2), R = Math.floor(N/2) - 4;
    return Array.from({length:N}, (_, r) => Array.from({length:N}, (_, c) => {
      const dist = Math.abs(r - cx) + Math.abs(c - cx);
      const isBorder = (dist <= R && dist >= R - 4);
      const isCrossH = Math.abs(r - cx) <= 1 && Math.abs(c - cx) <= R;
      const isCrossV = Math.abs(c - cx) <= 1 && Math.abs(r - cx) <= R;
      return isBorder || isCrossH || isCrossV;
    }));
  }

  function makeMaskQuadrants() {
    const M = Math.floor(N/2), q1 = Math.floor(M/2), q2 = M + Math.floor(M/2);
    const R = Math.floor(M/2) - 1, Rin = R - 3;
    const isBox = (r, c, cr, cc) => {
      const dr = Math.abs(r - cr), dc = Math.abs(c - cc);
      return (dr <= R && dc <= R) && !(dr <= Rin && dc <= Rin);
    };
    return Array.from({length:N}, (_, r) => Array.from({length:N}, (_, c) => {
      return isBox(r,c,q1,q1) || isBox(r,c,q1,q2) || isBox(r,c,q2,q1) || isBox(r,c,q2,q2) 
             || Math.abs(r - M) <= 1 || Math.abs(c - M) <= 1;
    }));
  }

  function makeMaskCross() {
    const C = Math.floor(N/2), Wout = 6, Win = 3, S = 3, E = N - 4;
    return Array.from({length:N}, (_, r) => Array.from({length:N}, (_, c) => {
      const inCross = (Math.abs(c - C) <= Wout && r >= S && r <= E) || 
                      (Math.abs(r - C) <= Wout && c >= S && c <= E);
      const inHoleV = Math.abs(c - C) <= Win && r >= S + 3 && r <= E - 3;
      const inHoleH = Math.abs(r - C) <= Win && c >= S + 3 && c <= E - 3;
      const inCenterHole = Math.abs(c - C) <= Win && Math.abs(r - C) <= Win;
      const isBridge = Math.abs(r - C) === 0 || Math.abs(c - C) === 0;
      return inCross && (!inHoleV && !inHoleH && !inCenterHole || isBridge);
    }));
  }

  const SHAPES = {
    '—Å–≤–æ–±–æ–¥–Ω–∞—è': makeMaskFree,
    '–∫–≤–∞–¥—Ä–∞—Ç': makeMaskSquare,
    '—Ä–æ–º–±': makeMaskDiamond,
    '–∫—Ä–µ—Å—Ç': makeMaskCross,
    '–∫–≤–∞–¥—Ä–∞–Ω—Ç—ã': makeMaskQuadrants
  };

  function makeGrid() { return Array.from({length:N}, () => Array(N).fill('.')); }
  function doPlace(g, w, r, c, dir) { for (let i=0; i<w.length; i++) dir==='H' ? g[r][c+i]=w[i] : g[r+i][c]=w[i]; }
  function shuffle(arr) { for (let i=arr.length-1; i>0; i--) { const j = Math.floor(Math.random()*(i+1)); [arr[i], arr[j]]=[arr[j], arr[i]]; } return arr; }

  function canPlace(g, w, r, c, dir, mask) {
    const L = w.length;
    if (dir === 'H') { if (c < 0 || c + L > N || r < 0 || r >= N) return false; }
    else             { if (r < 0 || r + L > N || c < 0 || c >= N) return false; }

    if (mask) {
      for (let i=0; i<L; i++) {
        const rr = dir === 'H' ? r : r + i;
        const cc = dir === 'H' ? c + i : c;
        if (!mask[rr] || !mask[rr][cc]) return false;
      }
    }

    if (dir === 'H') {
      if (c > 0 && g[r][c-1] !== '.') return false;
      if (c + L < N && g[r][c+L] !== '.') return false;
      for (let i=0; i<L; i++) {
        const ch = g[r][c+i];
        if (ch !== '.' && ch !== w[i]) return false;
        if (ch === '.') {
          if (r > 0 && g[r-1][c+i] !== '.') return false;
          if (r < N-1 && g[r+1][c+i] !== '.') return false;
        }
      }
    } else {
      if (r > 0 && g[r-1][c] !== '.') return false;
      if (r + L < N && g[r+L][c] !== '.') return false;
      for (let i=0; i<L; i++) {
        const ch = g[r+i][c];
        if (ch !== '.' && ch !== w[i]) return false;
        if (ch === '.') {
          if (c > 0 && g[r+i][c-1] !== '.') return false;
          if (c < N-1 && g[r+i][c+1] !== '.') return false;
        }
      }
    }
    return true;
  }

  function getValidSlotsForWord(g, item, mask) {
    const w = item.w, slots = [];
    for (let r=1; r<N-1; r++) for (let c=1; c<N-1; c++) {
      for (const dir of ['H', 'V']) {
        if (!canPlace(g, w, r, c, dir, mask)) continue;
        let cross = 0, isAttached = false;
        for (let i=0; i<w.length; i++) {
          const rr = dir === 'H' ? r : r + i, cc = dir === 'H' ? c + i : c;
          if (g[rr][cc] === w[i]) cross++;
          if (g[rr][cc] !== '.') isAttached = true;
        }
        if (isAttached) slots.push({ r, c, dir, cross });
      }
    }
    return slots;
  }

  function getCOM(g, mask) {
  let sumR = 0, sumC = 0, cnt = 0;
  for (let r = 0; r < N; r++) {
    for (let c = 0; c < N; c++) {
      if (g[r][c] === '.') continue;        // —É—á–∏—Ç—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –±—É–∫–≤—ã
      if (mask && !mask[r][c]) continue;    // –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º –±—É–∫–≤—ã –≤–Ω–µ –º–∞—Å–∫–∏
      sumR += r; sumC += c; cnt++;
    }
  }
  if (!cnt) {
    if (mask) {
      let mR = 0, mC = 0, mCnt = 0;
      for (let r = 0; r < N; r++) for (let c = 0; c < N; c++) {
        if (mask[r][c]) { mR += r; mC += c; mCnt++; }
      }
      return { r: mCnt ? mR / mCnt : N / 2, c: mCnt ? mC / mCnt : N / 2 };
    }
    return { r: N / 2, c: N / 2 };
  }
  return { r: sumR / cnt, c: sumC / cnt };
}


  function tryBuildSmart(pool, mask=null) {
  const g = makeGrid(), placed = [];
  let available = [...pool], num = 1;
  available.sort((a, b) => b.w.length - a.w.length);
  const first = available.shift();

  const initialSlots = [];
  for (let r=1; r<N-1; r++) for (let c=1; c<N-1; c++) {
    if (!canPlace(g, first.w, r, c, 'H', mask)) continue;
    initialSlots.push({r,c,dir:'H'});
    if (!canPlace(g, first.w, r, c, 'V', mask)) continue;
    initialSlots.push({r,c,dir:'V'});
  }
  if (!initialSlots.length) return { g, placed: [] };

  // –ü–µ—Ä–≤–æ–µ —Å–ª–æ–≤–æ –≤ —Ü–µ–Ω—Ç—Ä –º–∞—Å–∫–∏
  const start = initialSlots[Math.floor(Math.random() * initialSlots.length)];
  doPlace(g, first.w, start.r, start.c, start.dir);
  placed.push({ ...first, r: start.r, c: start.c, dir: start.dir, num: num++ });

  let added;
  do {
    added = false;
    shuffle(available);
    for (let i=0; i<available.length; i++) {
      const item = available[i];
      const slots = getValidSlotsForWord(g, item, mask);
      if (!slots.length) continue;
      
      // –ü—Ä–æ—Å—Ç–æ –º–∞–∫—Å–∏–º—É–º –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π ‚Äî –±–µ–∑ —Å–ª–æ–∂–Ω–æ–π –ª–æ–≥–∏–∫–∏ —Ü–µ–Ω—Ç—Ä–∞ –º–∞—Å—Å
      slots.forEach(s => s.score = s.cross * 100); // –æ—á–µ–Ω—å –±–æ–ª—å—à–æ–π –≤–µ—Å –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π
      slots.sort((a, b) => b.score - a.score);
      
      const best = slots[0];
      doPlace(g, item.w, best.r, best.c, best.dir);
      placed.push({ ...item, r: best.r, c: best.c, dir: best.dir, num: num++ });
      available.splice(i, 1);
      added = true; break;
    }
  } while (added && placed.length < 28);

  placed.sort((a, b) => a.r !== b.r ? a.r - b.r : a.c - b.c);
  placed.forEach((p, i) => p.num = i + 1);
  return { g, placed };
}

  function buildBest(pool, attempts=15, mask=null) {
    let best = null;
    for (let i=0; i<attempts; i++) {
      const res = tryBuildSmart(pool, mask);
      if (!best || res.placed.length > best.placed.length) best = res;
      if (best.placed.length >= 25) break;
    }
    return best;
  }

  let CELL=32;
  const GPAD=24, TOPH=20, BPAD=30;

  function getResponsiveCell() {
  const vw = window.innerWidth;
  if (vw <= 420) return 20;
  if (vw <= 650) return 25;
  return 32;
  }


  function rrect(ctx,x,y,w,h,r) {
    ctx.beginPath(); ctx.moveTo(x+r,y); ctx.lineTo(x+w-r,y); ctx.quadraticCurveTo(x+w,y,x+w,y+r);
    ctx.lineTo(x+w,y+h-r); ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h); ctx.lineTo(x+r,y+h); 
    ctx.quadraticCurveTo(x,y+h,x,y+h-r); ctx.lineTo(x,y+r); ctx.quadraticCurveTo(x,y,x+r,y); ctx.closePath();
  }

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  –§–ò–õ–í–û–†–î (WORD SEARCH) ‚Äî –û–¢–î–ï–õ–¨–ù–´–ô –ë–õ–û–ö
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const PH_CELL = 32, PH_PAD = 24, PH_TOPH = 20, PH_BPAD = 22;
const PH_LETTERS = "–ê–ë–í–ì–î–ï–Å–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø";
const PH_DIRS = [
  {dr:0, dc:1}, {dr:0, dc:-1}, {dr:1, dc:0}, {dr:-1, dc:0},
  {dr:1, dc:1}, {dr:1, dc:-1}, {dr:-1, dc:1}, {dr:-1, dc:-1}
];

let phSize = 14;
let phGrid = [];
let phPlacements = []; // { w, cells:[{r,c}], r, c, dr, dc }
let phFound = new Set();
let phShowAnswers = false;

let phSelecting = false;
let phSelStart = null;  // {r,c}
let phSelEnd = null;    // {r,c}
let phSelCells = [];    // [{r,c}]

function philMakeGrid(size, fill = "") {
  return Array.from({ length: size }, () => Array(size).fill(fill));
}

function philRandLetter() {
  return PH_LETTERS[Math.floor(Math.random() * PH_LETTERS.length)];
}

function philNormWord(w) {
  return (w || "").toString().trim().toUpperCase();
}

function philGetPool(theme, level) {
  if (theme === "—Ñ–∏–∑–º–∞—Ç") {
    const phys = DB["—Ñ–∏–∑–∏–∫–∞"]?.[level] ?? [];
    const math = DB["–º–∞—Ç–µ–º–∞—Ç–∏–∫–∞"]?.[level] ?? [];
    return [...phys, ...math];
  }
  return DB[theme]?.[level] ?? [];
}

function philPickWords(pool, size, targetCount) {
  const filtered = pool
    .map(i => ({ w: philNormWord(i.w), q: i.q }))
    .filter(i => i.w.length >= 3 && i.w.length <= size)
    .filter(i => /^[–ê-–Ø–Å]+$/i.test(i.w));

  // —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ –ø–æ —Å–ª–æ–≤—É
  const uniq = new Map();
  filtered.forEach(i => { if (!uniq.has(i.w)) uniq.set(i.w, i); });

  let list = [...uniq.values()].filter(i => !philUsedWordsHistory.has(i.w));
  if (list.length < targetCount + 3) {
    philUsedWordsHistory.clear();
    list = [...uniq.values()];
  }

  // –¥–ª–∏–Ω–Ω—ã–µ –≤–ø–µ—Ä—ë–¥ (–ª—É—á—à–µ —É–∫–ª–∞–¥—ã–≤–∞—é—Ç—Å—è)
  list.sort((a, b) => b.w.length - a.w.length);

  // –±–µ—Ä—ë–º —á—É—Ç—å –±–æ–ª—å—à–µ, —á–µ–º –Ω–∞–¥–æ ‚Äî –Ω–∞ —Å–ª—É—á–∞–π —Ñ–µ–π–ª–æ–≤ –ø—Ä–∏ —Ä–∞–∑–º–µ—â–µ–Ω–∏–∏
  return list.slice(0, Math.min(list.length, targetCount + 8));
}

function philCanPlaceWord(grid, word, r, c, dr, dc) {
  const size = grid.length;
  const L = word.length;
  const r2 = r + dr * (L - 1);
  const c2 = c + dc * (L - 1);
  if (r < 0 || c < 0 || r >= size || c >= size) return false;
  if (r2 < 0 || c2 < 0 || r2 >= size || c2 >= size) return false;

  for (let i = 0; i < L; i++) {
    const rr = r + dr * i;
    const cc = c + dc * i;
    const ch = grid[rr][cc];
    if (ch !== "" && ch !== word[i]) return false;
  }
  return true;
}

function philPlaceWord(grid, word, r, c, dr, dc) {
  const cells = [];
  for (let i = 0; i < word.length; i++) {
    const rr = r + dr * i;
    const cc = c + dc * i;
    grid[rr][cc] = word[i];
    cells.push({ r: rr, c: cc });
  }
  return cells;
}

function philTryPlace(grid, word, attempts = 250) {
  const size = grid.length;
  for (let t = 0; t < attempts; t++) {
    const dir = PH_DIRS[Math.floor(Math.random() * PH_DIRS.length)];
    const r = Math.floor(Math.random() * size);
    const c = Math.floor(Math.random() * size);
    if (!philCanPlaceWord(grid, word, r, c, dir.dr, dir.dc)) continue;
    const cells = philPlaceWord(grid, word, r, c, dir.dr, dir.dc);
    return { r, c, dr: dir.dr, dc: dir.dc, cells };
  }
  return null;
}

function philFillEmpty(grid) {
  const size = grid.length;
  for (let r = 0; r < size; r++) for (let c = 0; c < size; c++) {
    if (!grid[r][c]) grid[r][c] = philRandLetter();
  }
}

function philRenderWordsList() {
  const box = document.getElementById("philWords");
  if (!box) return;

  let html = "";
  phPlacements.forEach((p, idx) => {
    const found = phFound.has(p.w);
    html += `<div class="phw-item ${found ? "found" : ""}" id="phw-${idx}"><b>${idx + 1}.</b> ${p.w}</div>`;
  });

  box.innerHTML = html || `<div class="clue-item">–°–ª–æ–≤–∞ –Ω–µ —Ä–∞–∑–º–µ—â–µ–Ω—ã</div>`;
}

function philUpdateStat() {
  const stat = document.getElementById("phil-stat");
  if (!stat) return;
  stat.textContent = `–ù–∞–π–¥–µ–Ω–æ: ${phFound.size}/${phPlacements.length} | –†–∞–∑–º–µ—Ä: ${phSize}√ó${phSize}`;
}

function philUpdatePanel(text = "") {
  const panel = document.getElementById("phil-active-panel");
  if (!panel) return;

  if (phPlacements.length && phFound.size === phPlacements.length) {
    panel.textContent = "üéâ –í—Å–µ —Å–ª–æ–≤–∞ –Ω–∞–π–¥–µ–Ω—ã!";
    panel.style.color = "#4ade80";
    markWin('philword');
    return;
  }

  panel.style.color = "#a855f7";
  panel.textContent = text || "–í—ã–¥–µ–ª—è–π—Ç–µ —Å–ª–æ–≤–∞ –ø—Ä–æ—Ç—è–∂–∫–æ–π: –ø–æ –ø—Ä—è–º–æ–π (8 –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–π)";
}

function philCellsKeySet(cells) {
  const s = new Set();
  cells.forEach(k => s.add(`${k.r},${k.c}`));
  return s;
}

function philDraw() {
  const cv = document.getElementById("cvPhil");
  if (!cv || !phGrid.length) return;

  const size = phGrid.length;
  cv.width = size * PH_CELL + PH_PAD * 2;
  cv.height = PH_TOPH + size * PH_CELL + PH_PAD * 2 + PH_BPAD;

  const ctx = cv.getContext("2d");

  const bg = ctx.createLinearGradient(0, 0, cv.width, cv.height);
  bg.addColorStop(0, "#06060f");
  bg.addColorStop(1, "#080816");
  ctx.fillStyle = bg;
  ctx.fillRect(0, 0, cv.width, cv.height);

  // —Ñ–æ–Ω–æ–≤—ã–µ –ª–∏–Ω–∏–∏
  ctx.strokeStyle = "#0e0e25";
  ctx.lineWidth = 1;
  for (let x = 0; x < cv.width; x += 40) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, cv.height); ctx.stroke(); }
  for (let y = 0; y < cv.height; y += 40) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(cv.width, y); ctx.stroke(); }

  // –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –ø–æ–¥—Å–≤–µ—Ç–æ–∫
  const selSet = philCellsKeySet(phSelCells || []);
  let ansSet = new Set();
  if (phShowAnswers) {
    phPlacements.forEach(p => p.cells.forEach(k => ansSet.add(`${k.r},${k.c}`)));
  }

  let foundSet = new Set();
  phPlacements.forEach(p => {
    if (!phFound.has(p.w)) return;
    p.cells.forEach(k => foundSet.add(`${k.r},${k.c}`));
  });

  for (let r = 0; r < size; r++) for (let c = 0; c < size; c++) {
    const x = PH_PAD + c * PH_CELL;
    const y = PH_PAD + PH_TOPH + r * PH_CELL;

    const key = `${r},${c}`;
    const isFound = foundSet.has(key);
    const isSel = selSet.has(key);
    const isAns = ansSet.has(key);

    // cell bg
    ctx.fillStyle = isFound ? "#0f301d" : (isSel ? "#2a2a60" : (isAns ? "#0c2430" : "#0d0d22"));
    rrect(ctx, x + 1, y + 1, PH_CELL - 2, PH_CELL - 2, 4);
    ctx.fill();

    // border
    ctx.strokeStyle = isSel ? "#00d4ff" : "#00d4ff38";
    ctx.lineWidth = isSel ? 2 : 1;
    rrect(ctx, x + 1, y + 1, PH_CELL - 2, PH_CELL - 2, 4);
    ctx.stroke();

    // letter
    ctx.fillStyle = isFound ? "#4ade80" : "#00d4ff";
    ctx.font = "bold " + Math.floor(PH_CELL * 0.52) + "px Segoe UI,sans-serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(phGrid[r][c], x + PH_CELL / 2, y + PH_CELL / 2 + 1);
  }
}

function philPointerToCell(e) {
  const cv = document.getElementById("cvPhil");
  if (!cv) return null;

  const rect = cv.getBoundingClientRect();
  const x = (e.clientX - rect.left) * (cv.width / rect.width);
  const y = (e.clientY - rect.top) * (cv.height / rect.height);

  const c = Math.floor((x - PH_PAD) / PH_CELL);
  const r = Math.floor((y - PH_PAD - PH_TOPH) / PH_CELL);

  if (r < 0 || c < 0 || r >= phSize || c >= phSize) return null;
  return { r, c };
}

function philBestDir(from, to) {
  let dr = to.r - from.r;
  let dc = to.c - from.c;
  if (dr === 0 && dc === 0) return { dr: 0, dc: 0, len: 0 };

  const adr = Math.abs(dr), adc = Math.abs(dc);

  // –≤—ã–±–∏—Ä–∞–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ ‚Äú—Å–∞–º–æ–µ –±–ª–∏–∑–∫–æ–µ‚Äù –∫ 8-–º–∏
  if (adr === adc) { // –¥–∏–∞–≥–æ–Ω–∞–ª—å
    dr = Math.sign(dr);
    dc = Math.sign(dc);
    return { dr, dc, len: adr };
  }

  if (adr > adc) { // –≤–µ—Ä—Ç–∏–∫–∞–ª—å
    dr = Math.sign(dr);
    dc = 0;
    return { dr, dc, len: adr };
  } else { // –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å
    dr = 0;
    dc = Math.sign(dc);
    return { dr, dc, len: adc };
  }
}

function philBuildLineCells(start, end) {
  const dir = philBestDir(start, end);
  const cells = [];
  for (let i = 0; i <= dir.len; i++) {
    const rr = start.r + dir.dr * i;
    const cc = start.c + dir.dc * i;
    if (rr < 0 || cc < 0 || rr >= phSize || cc >= phSize) break;
    cells.push({ r: rr, c: cc });
  }
  return cells;
}

function philStringFromCells(cells) {
  return cells.map(k => phGrid[k.r][k.c]).join("");
}

function philReverse(s) {
  return s.split("").reverse().join("");
}

function philCheckSelectionHit() {
  if (!phSelCells || phSelCells.length < 2) return false;

  const s = philStringFromCells(phSelCells);
  const sr = philReverse(s);

  const hit = phPlacements.find(p => !phFound.has(p.w) && (p.w === s || p.w === sr));
  if (!hit) return false;

  phFound.add(hit.w);
  philRenderWordsList();
  philUpdateStat();
  philUpdatePanel(`–ù–∞–π–¥–µ–Ω–æ: ${hit.w}`);
  return true;
}

function philPointerDown(e) {
  if (!phGrid.length) return;
  const cell = philPointerToCell(e);
  if (!cell) return;

  phSelecting = true;
  phSelStart = cell;
  phSelEnd = cell;
  phSelCells = [cell];
  philUpdatePanel("–¢—è–Ω–∏—Ç–µ –¥–æ –ø–æ—Å–ª–µ–¥–Ω–µ–π –±—É–∫–≤—ã —Å–ª–æ–≤–∞");
  philDraw();
}

function philPointerMove(e) {
  if (!phSelecting || !phSelStart) return;
  const cell = philPointerToCell(e);
  if (!cell) return;

  phSelEnd = cell;
  phSelCells = philBuildLineCells(phSelStart, phSelEnd);
  philDraw();
}

function philPointerUp() {
  if (!phSelecting) return;
  phSelecting = false;

  const ok = philCheckSelectionHit();
  phSelStart = null;
  phSelEnd = null;
  phSelCells = [];

  if (!ok) philUpdatePanel();
  philDraw();
}

function philToggleAnswers() {
  if (!phGrid.length) return;
  phShowAnswers = !phShowAnswers;
  const btn = document.getElementById("btn-ph-answ");
  if (btn) btn.textContent = phShowAnswers ? "üîí –°–∫—Ä—ã—Ç—å" : "üëÅ –û—Ç–≤–µ—Ç—ã";
  philDraw();
}

function philGenerateCore() {
  phShowAnswers = false;
  const btn = document.getElementById("btn-ph-answ");
  if (btn) btn.textContent = "üëÅ –û—Ç–≤–µ—Ç—ã";

  const sizeSel = document.getElementById("sel-size-ph");
  const themeSel = document.getElementById("sel-theme-ph");
  const levelSel = document.getElementById("sel-level-ph");
  if (!sizeSel || !themeSel || !levelSel) return;

  phSize = parseInt(sizeSel.value, 10) || 14;

  const theme = themeSel.value;
  const level = levelSel.value;

  const pool = philGetPool(theme, level);
  if (!pool.length) {
    document.getElementById("phil-stat").textContent = "‚ö†Ô∏è –ù–µ—Ç —Å–ª–æ–≤ –≤ –±–∞–∑–µ –¥–ª—è —ç—Ç–æ–≥–æ —Ä–µ–∂–∏–º–∞.";
    return;
  }

  // —Å–∫–æ–ª—å–∫–æ —Å–ª–æ–≤ —Ü–µ–ª–∏–º—Å—è —Å–ø—Ä—è—Ç–∞—Ç—å
  const target = phSize <= 12 ? 10 : (phSize <= 14 ? 12 : 14);
  const candidates = philPickWords(pool, phSize, target);

  const grid = philMakeGrid(phSize, "");
  const placements = [];

  for (const item of candidates) {
    const placed = philTryPlace(grid, item.w, 280);
    if (!placed) continue;

    placements.push({
      w: item.w,
      r: placed.r, c: placed.c,
      dr: placed.dr, dc: placed.dc,
      cells: placed.cells
    });

    philUsedWordsHistory.add(item.w);
    if (placements.length >= target) break;
  }

  philFillEmpty(grid);

  phGrid = grid;
  phPlacements = placements;
  phFound = new Set();

  philRenderWordsList();
  philUpdateStat();
  philUpdatePanel();
  philDraw();
}

function philGenerate() {
  if (!philHasProgress()) {
    philGenerateCore();
    return;
  }

  showConfirmPopup(
    '–°–±—Ä–æ—Å–∏—Ç—å —Ç–µ–∫—É—â–∏–π —Ñ–∏–ª–≤–æ—Ä–¥ –∏ —Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π?',
    () => philGenerateCore(),
    () => {}
  );
}


// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// –ö–í–ê–ù–¢ - –£–ì–ê–î–ê–ô –°–õ–û–í–û –ò–ó –¢–ï–†–ú–ò–ù–û–í
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const quantWordsUsed = new Set();
let quantCurrentWord = '';
let quantCurrentGuess = '';
let quantAttempts = 6;
let quantWins = 0;
let quantGameOver = false;
let quantWon = false;
let quantHint = '';

function quantGetPool(theme, level) {
 if (theme === '—Ñ–∏–∑–º–∞—Ç') {
  const phys = DB['—Ñ–∏–∑–∏–∫–∞']?.[level] ?? [];
  const math = DB['–º–∞—Ç–µ–º–∞—Ç–∏–∫–∞']?.[level] ?? [];
  return [...phys, ...math];
 }
 return DB[theme]?.[level] ?? [];
}

function quantPickWord(pool, minLen = 5, maxLen = 5) {
 let candidates = pool
  .map(i => ({ w: (i.w || '').toUpperCase(), q: i.q }))
  .filter(i => i.w.length >= minLen && i.w.length <= maxLen && /^[–ê-–Ø–Å]+$/.test(i.w));
 
 const uniq = new Map();
 candidates.forEach(i => {
  if (!uniq.has(i.w)) uniq.set(i.w, i);
 });
 
 let list = [...uniq.values()].filter(i => !quantWordsUsed.has(i.w));
 if (list.length < 3) { quantWordsUsed.clear(); list = [...uniq.values()]; }
 if (!list.length) return null;
 
 const picked = list[Math.floor(Math.random() * list.length)];
 quantWordsUsed.add(picked.w);
 return picked;
}

function quantDrawGrid() {
 const grid = document.getElementById('qntGrid');
 if (!grid) return;
 grid.innerHTML = '';
 
 const wordLength = quantCurrentWord.length || 5;
 grid.style.gridTemplateColumns = `repeat(${wordLength}, 1fr)`;
 
 for (let i = 0; i < wordLength; i++) {
  const cell = document.createElement('div');
  cell.className = 'qnt-letter';
  cell.textContent = quantCurrentGuess[i] || '';
  grid.appendChild(cell);
 }
}



function quantDrawKeyboard() {
 const kb = document.getElementById('qntKeyboard');
 if (!kb) return;
 kb.innerHTML = '';
 
   const rows = [
    '–ô–¶–£–ö–ï–ù–ì–®–©–ó–•–™'.split(''),
    '–§–´–í–ê–ü–†–û–õ–î–ñ–≠'.split(''),
    ['–Ø','–ß','–°','–ú','–ò','–¢','–¨','–ë','–Æ','‚å´'] // –î–æ–±–∞–≤–∏–ª–∏ ‚å´ –≤ –∫–æ–Ω–µ—Ü —Ç—Ä–µ—Ç—å–µ–≥–æ —Ä—è–¥–∞
  ];

 
 rows.forEach(row => {
  const rowDiv = document.createElement('div');
  rowDiv.className = 'qnt-key-row';
  
  row.forEach(letter => {
   const btn = document.createElement('button');
   btn.className = 'qnt-key';
   btn.textContent = letter;
   btn.onclick = () => {
        if (letter === '‚å´') {
          // –ï—Å–ª–∏ –Ω–∞–∂–∞–ª–∏ —Å—Ç–µ—Ä–µ—Ç—å, —É–±–∏—Ä–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω—é—é –±—É–∫–≤—É
          if (quantCurrentGuess.length > 0 && !quantGameOver) {
            quantCurrentGuess = quantCurrentGuess.slice(0, -1);
            quantDrawGrid();
          }
        } else {
          // –ò–Ω–∞—á–µ –≤–≤–æ–¥–∏–º –±—É–∫–≤—É
          quantGuessLetter(letter);
        }
      };
   rowDiv.appendChild(btn);
  });
  
  kb.appendChild(rowDiv);
 });
}

function quantGuessLetter(letter) {
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∏–≥—Ä–∞ –∏–¥–µ—Ç –∏ –¥–ª–∏–Ω–∞ –≤–≤–æ–¥–∞ –º–µ–Ω—å—à–µ –¥–ª–∏–Ω—ã –∑–∞–≥–∞–¥–∞–Ω–Ω–æ–≥–æ —Å–ª–æ–≤–∞
  if (quantGameOver || !quantCurrentWord || quantCurrentGuess.length >= quantCurrentWord.length) return;
  
  quantCurrentGuess += letter;
  quantDrawGrid();
  
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–ø—ã—Ç–∫—É —Ç–æ–ª—å–∫–æ —Ç–æ–≥–¥–∞, –∫–æ–≥–¥–∞ –≤–≤–µ–¥–µ–Ω–æ —Å—Ç–æ–ª—å–∫–æ –∂–µ –±—É–∫–≤, —Å–∫–æ–ª—å–∫–æ –≤ —Å–ª–æ–≤–µ
  if (quantCurrentGuess.length === quantCurrentWord.length) {
    setTimeout(quantCheckGuess, 500);
  }
}


function quantCheckGuess() {
 if (quantCurrentGuess === quantCurrentWord) {
  quantWon = true;
  quantGameOver = true;
  quantWins++;
  document.getElementById('qnt-active-panel').textContent = 'üéâ –ü–†–ê–í–ò–õ–¨–ù–û! ' + quantCurrentWord;
  document.getElementById('qnt-active-panel').style.color = '#4ade80';
  document.getElementById('qnt-wins').textContent = quantWins;
  markWin('quant');
  quantDrawGrid();
  return;
 }
 
 quantAttempts--;
 document.getElementById('qnt-attempts').textContent = quantAttempts;
 
 if (quantAttempts <= 0) {
  quantGameOver = true;
  document.getElementById('qnt-active-panel').textContent = '‚ùå –ù–ï–ü–†–ê–í–ò–õ–¨–ù–û! –°–ª–æ–≤–æ: ' + quantCurrentWord;
  document.getElementById('qnt-active-panel').style.color = '#ff4444';
  quantDrawGrid();
  return;
 }
 
 quantCurrentGuess = '';
 document.getElementById('qnt-active-panel').textContent = `–û—Å—Ç–∞–ª–æ—Å—å –ø–æ–ø—ã—Ç–æ–∫: ${quantAttempts}`;
 quantDrawGrid();
}

function quantShowHint() {
 if (quantGameOver || !quantCurrentWord) return;
 const revealed = Math.floor(quantCurrentWord.length / 2);
 let hint = '';
 for (let i = 0; i < quantCurrentWord.length; i++) {
  hint += i < revealed ? quantCurrentWord[i] : '_';
 }
 document.getElementById('qnt-active-panel').textContent = 'üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞: ' + hint;
}


function quantGenerateCore() {
 const theme = document.getElementById('sel-theme-qnt')?.value || '—Ñ–∏–∑–∏–∫–∞';
 const level = document.getElementById('sel-level-qnt')?.value || '–ª–µ–≥–∫–∏–π';
 
 let minLen = 5, maxLen = 5;
 if (level === '—Å—Ä–µ–¥–Ω–∏–π') { minLen = 6; maxLen = 7; }
 if (level === '—Å–ª–æ–∂–Ω—ã–π') { minLen = 7; maxLen = 10; }
 
 const pool = quantGetPool(theme, level);

 if (!pool.length) {
  document.getElementById('qnt-stat').textContent = '‚ö†Ô∏è –ù–µ—Ç —Å–ª–æ–≤ –≤ –±–∞–∑–µ';
  return;
 }
 
 const picked = quantPickWord(pool, minLen, maxLen);
 if (!picked) return;
 
 quantCurrentWord = picked.w;
 quantCurrentGuess = '';
 quantAttempts = 6;
 quantGameOver = false;
 quantWon = false;
 quantHint = picked.q;
 
 document.getElementById('qnt-active-panel').textContent = 'üìù ' + picked.q;
 document.getElementById('qnt-active-panel').style.color = '#06f3ff';
 document.getElementById('qnt-attempts').textContent = quantAttempts;
 document.getElementById('qnt-stat').textContent = `–°–ª–æ–≤–æ –∏–∑ ${quantCurrentWord.length} –±—É–∫–≤ | ${theme} | ${level}`;
 
 quantDrawGrid();
 quantDrawKeyboard();
}

function quantGenerate() {
  if (!quantHasProgress()) {
    quantGenerateCore();
    return;
  }

  showConfirmPopup(
    '–ù–∞—á–∞—Ç—å –Ω–æ–≤—É—é –∏–≥—Ä—É –∏ —Å–±—Ä–æ—Å–∏—Ç—å —Ç–µ–∫—É—â–∏–µ –ø–æ–ø—ã—Ç–∫–∏?',
    () => quantGenerateCore(),
    () => {}
  );
}

function quantReset() {
 quantCurrentWord = '';
 quantCurrentGuess = '';
 quantAttempts = 6;
 quantGameOver = false;
 quantWon = false;
 document.getElementById('qnt-active-panel').textContent = '–ù–∞–∂–º–∏—Ç–µ "–ù–æ–≤–æ–µ —Å–ª–æ–≤–æ"';
 document.getElementById('qnt-active-panel').style.color = '#06f3ff';
 quantDrawGrid();
}

function philInitOnce() {
  if (window.__philInited) return;
  window.__philInited = true;

  const cv = document.getElementById("cvPhil");
  if (cv) {
    cv.addEventListener("pointerdown", philPointerDown);
    window.addEventListener("pointermove", philPointerMove, { passive: true });
    window.addEventListener("pointerup", philPointerUp, { passive: true });
    window.addEventListener("pointercancel", philPointerUp, { passive: true });
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  –°–£–î–û–ö–£ (SUDOKU) ‚Äî –û–¢–î–ï–õ–¨–ù–´–ô –ë–õ–û–ö
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const SU_CELL = 42, SU_PAD = 10;
let suGrid = [];       // —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ (0 - –ø—É—Å—Ç–æ)
let suSolution = [];   // –ø–æ–ª–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ
let suFixed = [];      // –º–∞—Å–∫–∞: true –µ—Å–ª–∏ —ç—Ç–æ —Å—Ç–∞—Ä—Ç–æ–≤–∞—è —Ü–∏—Ñ—Ä–∞ (–Ω–µ–ª—å–∑—è –º–µ–Ω—è—Ç—å)
let suSelR = -1, suSelC = -1;
let suErrors = new Set(); // –æ—à–∏–±–∫–∏ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ

function sudokuGenerateCore() {
  const diff = document.getElementById('sel-diff-su').value;
  
  // 1. –ë–∞–∑–æ–≤–∞—è —Å–µ—Ç–∫–∞ (—Å–¥–≤–∏–≥)
  const base = [1,2,3,4,5,6,7,8,9];
  suSolution = [];
  for(let r=0; r<9; r++) {
    const shift = (Math.floor(r / 3) + (r % 3) * 3) % 9; // 0,3,6, 1,4,7, 2,5,8
    const row = [];
    for(let c=0; c<9; c++) row.push(base[(c + shift) % 9]);
    suSolution.push(row);
  }

  // 2. –ü–µ—Ä–µ–º–µ—à–∏–≤–∞–Ω–∏–µ (Shuffling)
  // –°–≤–∞–ø —Å—Ç—Ä–æ–∫ –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö —Ä–∞–π–æ–Ω–æ–≤
  for(let i=0; i<20; i++) {
    const block = Math.floor(Math.random()*3);
    const r1 = block*3 + Math.floor(Math.random()*3);
    const r2 = block*3 + Math.floor(Math.random()*3);
    const temp = suSolution[r1]; suSolution[r1] = suSolution[r2]; suSolution[r2] = temp;
  }
  // –°–≤–∞–ø –∫–æ–ª–æ–Ω–æ–∫ –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö —Ä–∞–π–æ–Ω–æ–≤
  for(let i=0; i<20; i++) {
    const block = Math.floor(Math.random()*3);
    const c1 = block*3 + Math.floor(Math.random()*3);
    const c2 = block*3 + Math.floor(Math.random()*3);
    for(let r=0; r<9; r++) {
       const temp = suSolution[r][c1]; suSolution[r][c1] = suSolution[r][c2]; suSolution[r][c2] = temp;
    }
  }
  // –°–≤–∞–ø —Ä–∞–π–æ–Ω–æ–≤ —Å—Ç—Ä–æ–∫ (0-2, 3-5, 6-8)
  for(let i=0; i<5; i++) {
    const b1 = Math.floor(Math.random()*3);
    const b2 = Math.floor(Math.random()*3);
    if(b1 !== b2) {
      for(let k=0; k<3; k++) {
        const temp = suSolution[b1*3+k]; suSolution[b1*3+k] = suSolution[b2*3+k]; suSolution[b2*3+k] = temp;
      }
    }
  }

  // 3. –£–¥–∞–ª–µ–Ω–∏–µ —Ü–∏—Ñ—Ä (Dignig holes)
  suGrid = suSolution.map(r => [...r]);
  suFixed = Array.from({length:9}, () => Array(9).fill(true));
  
  let attempts = 30; // –ª–µ–≥–∫–∏–π
  if(diff === 'medium') attempts = 45;
  if(diff === 'hard') attempts = 56;
  if(diff === 'insane') attempts = 64;

  while(attempts > 0) {
    const r = Math.floor(Math.random()*9);
    const c = Math.floor(Math.random()*9);
    if(suGrid[r][c] !== 0) {
      suGrid[r][c] = 0;
      suFixed[r][c] = false;
      attempts--;
    }
  }

  suSelR = -1; suSelC = -1;
  suErrors.clear();
  document.getElementById('su-stat').textContent = `–°–ª–æ–∂–Ω–æ—Å—Ç—å: ${diff.toUpperCase()}`;
  document.getElementById('su-active-panel').textContent = "–í—ã–±–µ—Ä–∏—Ç–µ –∫–ª–µ—Ç–∫—É –∏ –≤–≤–µ–¥–∏—Ç–µ —Ü–∏—Ñ—Ä—É";
  document.getElementById('su-active-panel').style.color = "#fbbf24";
  
  sudokuDraw();
}

function sudokuGenerate() {
  if (!sudokuHasProgress()) {
    sudokuGenerateCore();
    return;
  }

  showConfirmPopup(
    '–°–±—Ä–æ—Å–∏—Ç—å —Ç–µ–∫—É—â–µ–µ —Å—É–¥–æ–∫—É –∏ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –Ω–æ–≤–æ–µ?',
    () => sudokuGenerateCore(),
    () => {}
  );
}


function sudokuDraw() {
  const cv = document.getElementById('cvSudoku');
  if(!cv) return;
  const ctx = cv.getContext('2d');
  
  const W = SU_CELL * 9 + SU_PAD * 2;
  cv.width = W; cv.height = W;

  // –§–æ–Ω
  const bg = ctx.createLinearGradient(0,0,W,W);
  bg.addColorStop(0,'#06060f'); bg.addColorStop(1,'#101025');
  ctx.fillStyle = bg; ctx.fillRect(0,0,W,W);

  if(!suGrid.length) return;

  const getX = (c) => SU_PAD + c * SU_CELL;
  const getY = (r) => SU_PAD + r * SU_CELL;

  for(let r=0; r<9; r++) {
    for(let c=0; c<9; c++) {
      const val = suGrid[r][c];
      const fixed = suFixed[r][c];
      const x = getX(c), y = getY(r);
      const isSel = (r === suSelR && c === suSelC);
      const isErr = suErrors.has(`${r},${c}`);

      // –§–æ–Ω –∫–ª–µ—Ç–∫–∏
      if(isSel) ctx.fillStyle = "#2a2a60";
      else if(isErr) ctx.fillStyle = "#3f1a1a";
      else if(fixed) ctx.fillStyle = "#12122a";
      else ctx.fillStyle = "#0a0a18"; // —é–∑–µ—Ä—Å–∫–∞—è –ø—É—Å—Ç–∞—è/–∑–∞–ø–æ–ª–Ω–µ–Ω–Ω–∞—è
      
      ctx.fillRect(x, y, SU_CELL, SU_CELL);

      // –¢–µ–∫—Å—Ç
      if(val !== 0) {
        ctx.fillStyle = fixed ? "#666688" : (isErr ? "#ff4444" : "#00d4ff");
        if(isSel) ctx.fillStyle = "#fff";
        ctx.font = (fixed ? "bold " : "") + "20px Segoe UI";
        ctx.textAlign = "center"; ctx.textBaseline = "middle";
        ctx.fillText(val, x + SU_CELL/2, y + SU_CELL/2 + 2);
      }

      // –°–µ—Ç–∫–∞ —Ç–æ–Ω–∫–∞—è
      ctx.strokeStyle = "#222244"; ctx.lineWidth = 1;
      ctx.strokeRect(x, y, SU_CELL, SU_CELL);
    }
  }

  // –ñ–∏—Ä–Ω–∞—è —Å–µ—Ç–∫–∞ 3x3
  ctx.strokeStyle = "#00d4ff"; ctx.lineWidth = 2;
  ctx.beginPath();
  for(let i=0; i<=9; i+=3) {
    ctx.moveTo(getX(i), getY(0)); ctx.lineTo(getX(i), getY(9));
    ctx.moveTo(getX(0), getY(i)); ctx.lineTo(getX(9), getY(i));
  }
  ctx.stroke();

  // –ê–∫—Ç–∏–≤–Ω–∞—è —Ä–∞–º–∫–∞
  if(suSelR !== -1) {
    ctx.strokeStyle = "#fbbf24"; ctx.lineWidth = 2;
    ctx.strokeRect(getX(suSelC), getY(suSelR), SU_CELL, SU_CELL);
  }
}

function sudokuClick(e) {
  const cv = document.getElementById('cvSudoku');
  if(!cv) return;
  const rect = cv.getBoundingClientRect();
  const x = (e.clientX - rect.left) * (cv.width / rect.width);
  const y = (e.clientY - rect.top) * (cv.height / rect.height);
  
  const c = Math.floor((x - SU_PAD) / SU_CELL);
  const r = Math.floor((y - SU_PAD) / SU_CELL);

  if(r>=0 && r<9 && c>=0 && c<9) {
    suSelR = r; suSelC = c;
    sudokuDraw();
  }
}

function sudokuInput(num) { // num: 0..9 (0 = clear)
  if(suSelR === -1 || suFixed[suSelR][suSelC]) return;
  suGrid[suSelR][suSelC] = num;
  suErrors.delete(`${suSelR},${suSelC}`); // —Å–±—Ä–æ—Å –æ—à–∏–±–∫–∏ –ø—Ä–∏ –≤–≤–æ–¥–µ
  sudokuDraw();
  
  // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø–æ–±–µ–¥—É
  let filled = true;
  for(let r=0; r<9; r++) for(let c=0; c<9; c++) if(suGrid[r][c]===0) filled=false;
  if(filled) {
     // –±—ã—Å—Ç—Ä–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞
     let win = true;
     for(let r=0; r<9; r++) for(let c=0; c<9; c++) if(suGrid[r][c] !== suSolution[r][c]) win=false;
     if(win) {
       document.getElementById('su-active-panel').textContent = "üéâ –°–£–î–û–ö–£ –†–ï–®–ï–ù–û –í–ï–†–ù–û!";
       document.getElementById('su-active-panel').style.color = "#4ade80";
       markWin('sudoku');
     }
  }
}

function sudokuCheck() {
  suErrors.clear();
  let errorsCount = 0;
  for(let r=0; r<9; r++) {
    for(let c=0; c<9; c++) {
      if(suGrid[r][c] !== 0 && suGrid[r][c] !== suSolution[r][c]) {
        suErrors.add(`${r},${c}`);
        errorsCount++;
      }
    }
  }
  sudokuDraw();
  const p = document.getElementById('su-active-panel');
  if(errorsCount === 0) {
    p.textContent = "‚úÖ –û—à–∏–±–æ–∫ –Ω–µ—Ç"; p.style.color = "#4ade80";
  } else {
    p.textContent = `‚ùå –ù–∞–π–¥–µ–Ω–æ –æ—à–∏–±–æ–∫: ${errorsCount}`; p.style.color = "#ff4444";
  }
}

function sudokuReset() {
  for(let r=0; r<9; r++) for(let c=0; c<9; c++) if(!suFixed[r][c]) suGrid[r][c] = 0;
  suErrors.clear();
  sudokuDraw();
}

function sudokuInitOnce() {
  if(window.__suInited) return;
  window.__suInited = true;
  
  const cv = document.getElementById('cvSudoku');
  if(cv) {
    // –í–°–¢–ê–í–õ–Ø–¢–¨ –°–Æ–î–ê: –û–±–µ—Ä–Ω—É–ª–∏ sudokuClick –≤ —Å—Ç—Ä–µ–ª–æ—á–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é, —á—Ç–æ–±—ã –¥–æ–±–∞–≤–∏—Ç—å —Ñ–æ–∫—É—Å
    cv.addEventListener('pointerdown', e => {
      sudokuClick(e);
    });

  }
  
  // –ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞
  window.addEventListener('keydown', e => {
    if (e.target.id === 'hidden-input') return;
    if(document.getElementById('sec-sudoku').classList.contains('active')) {
      if(e.key >= '1' && e.key <= '9') sudokuInput(parseInt(e.key));
      if(e.key === 'Backspace' || e.key === 'Delete' || e.key === '0') sudokuInput(0);
      
      // –°—Ç—Ä–µ–ª–∫–∏
      if(suSelR !== -1) {
        if(e.key==='ArrowUp' && suSelR>0) suSelR--;
        if(e.key==='ArrowDown' && suSelR<8) suSelR++;
        if(e.key==='ArrowLeft' && suSelC>0) suSelC--;
        if(e.key==='ArrowRight' && suSelC<8) suSelC++;
        sudokuDraw();
      }
    }
  });
}

  function drawCrossword(g, placed) {
  CELL = getResponsiveCell();
  
  // –ñ–Å–°–¢–ö–ò–ô –†–ê–ó–ú–ï–† –•–û–õ–°–¢–ê ‚Äî –í–°–ï–ì–î–ê
  const targetSize = window.innerWidth <= 650 ? 380 : 600;
  
  const cv = document.getElementById('cv');
  cv.width = targetSize;
  cv.height = targetSize;
  
  const ctx = cv.getContext('2d');

  // –§–æ–Ω
  const bg = ctx.createLinearGradient(0, 0, cv.width, cv.height);
  bg.addColorStop(0, '#06060f');
  bg.addColorStop(1, '#080816');
  ctx.fillStyle = bg;
  ctx.fillRect(0, 0, cv.width, cv.height);

  // –°–µ—Ç–∫–∞ —Ñ–æ–Ω–∞
  ctx.strokeStyle = '#0e0e25';
  ctx.lineWidth = 1;
  for (let x = 0; x < cv.width; x += 40) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, cv.height); ctx.stroke(); }
  for (let y = 0; y < cv.height; y += 40) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(cv.width, y); ctx.stroke(); }

  // –í—ã—á–∏—Å–ª—è–µ–º –≥—Ä–∞–Ω–∏—Ü—ã –∫—Ä–æ—Å—Å–≤–æ—Ä–¥–∞
  const rs = [], cs = [];
  for(let r=0; r<N; r++) for(let c=0; c<N; c++) if(g[r][c]!=='.') { rs.push(r); cs.push(c); }
  if(!rs.length) return;

  const rMin = Math.max(0, Math.min(...rs) - 1);
  const rMax = Math.min(N - 1, Math.max(...rs) + 1);
  const cMin = Math.max(0, Math.min(...cs) - 1);
  const cMax = Math.min(N - 1, Math.max(...cs) + 1);
  
  window.lastBounds = { rMin, cMin };

  // –í—ã—á–∏—Å–ª—è–µ–º –º–∞—Å—à—Ç–∞–± —Ç–∞–∫, —á—Ç–æ–±—ã –∫—Ä–æ—Å—Å–≤–æ—Ä–¥ –≤–ª–µ–∑ –≤ —Ö–æ–ª—Å—Ç
  const gridWidth = (cMax - cMin + 1) * CELL;
  const gridHeight = (rMax - rMin + 1) * CELL;
  const maxDim = Math.max(gridWidth, gridHeight);
  const availableSpace = targetSize - GPAD * 2 - 20; // 20px –Ω–∞ –ø–æ–≥—Ä–µ—à–Ω–æ—Å—Ç—å
  const scale = Math.min(1, availableSpace / maxDim);

  // –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –∏ –º–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º
  const offsetX = (targetSize - gridWidth * scale) / 2;
  const offsetY = (targetSize - gridHeight * scale) / 2;

  ctx.save();
  ctx.translate(offsetX, offsetY);
  ctx.scale(scale, scale);

  const numMap = {};
  placed.forEach(p => { if(!numMap[`${p.r},${p.c}`]) numMap[`${p.r},${p.c}`] = p.num; });

  for(let r = rMin; r <= rMax; r++) {
    for(let c = cMin; c <= cMax; c++) {
      if(g[r][c]==='.') continue;
      
      const x = (c - cMin) * CELL;
      const y = (r - rMin) * CELL;
      
      let isActive = false;
      let isCursor = (r === activeR && c === activeC);

      if(activeWord) {
        if(activeWord.dir==='H' && r===activeWord.r && c>=activeWord.c && c<activeWord.c+activeWord.w.length) isActive=true;
        if(activeWord.dir==='V' && c===activeWord.c && r>=activeWord.r && r<activeWord.r+activeWord.w.length) isActive=true;
      }

      ctx.fillStyle = isSolved ? '#0f301d' : (isCursor ? '#2a2a60' : (isActive ? '#1a1a40' : '#0d0d22'));
      rrect(ctx, x+1, y+1, CELL-2, CELL-2, 4);
      ctx.fill();

      ctx.strokeStyle = isCursor ? '#00d4ff' : '#00d4ff38';
      ctx.lineWidth = isCursor ? 2 : 1;
      rrect(ctx, x+1, y+1, CELL-2, CELL-2, 4);
      ctx.stroke();

      let letter, letterColor;
      if (isSolved) {
        letter = g[r][c];
        letterColor = '#4ade80';
      } else if (userGrid[r][c]) {
        letter = userGrid[r][c];
        letterColor = '#fbbf24';
      } else if (showAnswers) {
        letter = g[r][c];
        letterColor = 'rgba(0, 212, 255, 0.4)';
      } else {
        letter = '';
      }
      if (letter) {
        ctx.fillStyle = letterColor;
        ctx.font = 'bold ' + Math.floor(CELL * 0.52) + 'px Segoe UI,sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(letter, x + CELL/2, y + CELL/2 + 1);
      }

      if(numMap[`${r},${c}`]) {
        ctx.fillStyle='#ff6b35';
        ctx.font='bold 9px Segoe UI,sans-serif';
        ctx.textAlign='left';
        ctx.textBaseline='top';
        ctx.fillText(numMap[`${r},${c}`], x+3, y+2);
      }
    }
  }

  ctx.restore();
}

    function updateUI() {
    const panel = document.getElementById('active-q-panel');
    
    if(isSolved) {
      markWin('crossword');
      panel.innerHTML = 'üéâ –ü–û–ó–î–†–ê–í–õ–Ø–ï–ú! –ö–†–û–°–°–í–û–†–î –†–ê–ó–ì–ê–î–ê–ù! üéâ';
      panel.style.color = '#4ade80';
    } else if(activeWord) {
      const dirText = activeWord.dir === 'H' ? '–ü–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–∏' : '–ü–æ –≤–µ—Ä—Ç–∏–∫–∞–ª–∏';
      panel.innerHTML = `<span style="color:#a855f7;">[${dirText}, ${activeWord.num}]</span> &nbsp; ${activeWord.q}`;
      panel.style.color = '#ff6b35';
    } else {
      panel.innerHTML = '–ö–ª–∏–∫–Ω–∏—Ç–µ –ø–æ –∫–ª–µ—Ç–∫–µ –¥–ª—è –Ω–∞—á–∞–ª–∞';
      panel.style.color = '#ff6b35';
    }

    // –£–±–∏—Ä–∞–µ–º –ø–æ–¥—Å–≤–µ—Ç–∫—É —Å–æ –≤—Å–µ—Ö –≤–æ–ø—Ä–æ—Å–æ–≤
    document.querySelectorAll('.clue-item').forEach(el => el.classList.remove('active'));
    
    // –ü–æ–¥—Å–≤–µ—á–∏–≤–∞–µ–º –Ω—É–∂–Ω—ã–π –∏ —Å–∫—Ä–æ–ª–ª–∏–º –¢–û–õ–¨–ö–û –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä (–±–µ–∑ –¥–µ—Ä–≥–∞–Ω—å—è —ç–∫—Ä–∞–Ω–∞)
    if(activeWord) {
      const el = document.getElementById('clue-' + activeWord.num + '-' + activeWord.dir);
      if(el) {
        el.classList.add('active');
        
        const container = document.getElementById('cluesList');
        // –í—ã—á–∏—Å–ª—è–µ–º —Ç–æ—á–Ω—É—é –ø–æ–∑–∏—Ü–∏—é —Å–∫—Ä–æ–ª–ª–∞ –¥–ª—è —Å–∞–π–¥–±–∞—Ä–∞
        const targetScroll = el.getBoundingClientRect().top - container.getBoundingClientRect().top + container.scrollTop - (container.clientHeight / 2) + (el.clientHeight / 2);
        
        // –°–∫—Ä–æ–ª–ª–∏–º —Ç–æ–ª—å–∫–æ —Å–∞–º —Å–ø–∏—Å–æ–∫
        container.scrollTo({ top: targetScroll, behavior: 'smooth' });
      }
    }
        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–∏—Ä–∏–ª–ª–∏—á–µ—Å–∫—É—é –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É —Ç–æ–ª—å–∫–æ –Ω–∞ –º–æ–±–∏–ª–∫–∞—Ö
        const kp = document.getElementById('cw-keypad');
        if (kp) kp.classList.toggle('visible', !!(activeWord && !isSolved));
  }


  function renderCluesList(placed) {
    const box = document.getElementById('cluesList');
    const hor = placed.filter(p => p.dir === 'H').sort((a,b)=>a.num-b.num);
    const ver = placed.filter(p => p.dir === 'V').sort((a,b)=>a.num-b.num);
    
    let html = `<div class="clues-section"><h3>–ü–û –ì–û–†–ò–ó–û–ù–¢–ê–õ–ò</h3>`;
    hor.forEach(p => html += `<div class="clue-item" id="clue-${p.num}-H"><b>${p.num}.</b> ${p.q}</div>`);
    html += `</div><div class="clues-section"><h3>–ü–û –í–ï–†–¢–ò–ö–ê–õ–ò</h3>`;
    ver.forEach(p => html += `<div class="clue-item" id="clue-${p.num}-V"><b>${p.num}.</b> ${p.q}</div>`);
    html += `</div>`;
    box.innerHTML = html;
  }

  function checkWin() {
    if(!window.lastG) return;
    let win = true;
    for(let r=0;r<N;r++) for(let c=0;c<N;c++) if(window.lastG[r][c]!=='.' && userGrid[r][c]!==window.lastG[r][c]) win=false;
    if(win) { isSolved=true; activeWord=null; activeR=-1; activeC=-1; updateUI(); }
  }

  function onGenerateCore() {
    showAnswers = false;
    document.getElementById('btn-answ').textContent = 'üëÅ –û—Ç–≤–µ—Ç—ã';

    const theme = document.getElementById('sel-theme').value;
    const level = document.getElementById('sel-level').value;
    
    let pool = [];
    if (theme === '—Ñ–∏–∑–º–∞—Ç') {
      const phys = DB['—Ñ–∏–∑–∏–∫–∞']?.[level] ?? [];
      const math = DB['–º–∞—Ç–µ–º–∞—Ç–∏–∫–∞']?.[level] ?? [];
      pool = [...phys, ...math];
    } else {
      pool = DB[theme]?.[level] ?? [];
    }

    if(pool.length < 4) return;

    let available = pool.filter(i => !usedWordsHistory.has(i.w));
    if(available.length < 10) { usedWordsHistory.clear(); available = [...pool]; }

    // –ñ–Å–°–¢–ö–ê–Ø –ú–ê–°–ö–ê 20√ó20 –ö–í–ê–î–†–ê–¢
    const mask = makeMaskFree();

    // –ë–û–õ–¨–®–ï –ü–û–ü–´–¢–û–ö –î–õ–Ø –ö–ê–ñ–î–û–ì–û –£–†–û–í–ù–Ø
    let attempts = 15;
    if(level === '—Å—Ä–µ–¥–Ω–∏–π') attempts = 30;
    if(level === '—Å–ª–æ–∂–Ω—ã–π') attempts = 50;

    requestAnimationFrame(() => {
      const res = buildBest(available, attempts, mask);
      if(!res || !res.placed.length) { document.getElementById('stat').textContent='‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è.'; return; }

      const {g, placed} = res;
      placed.forEach(p => usedWordsHistory.add(p.w));
      window.lastG=g;
      window.lastPlaced=placed;
      
      userGrid = Array.from({length:N}, ()=>Array(N).fill(''));
      activeWord=null;
      activeR=-1;
      activeC=-1;
      isSolved=false;

      renderCluesList(placed);
      updateUI();
      drawCrossword(g, placed);

      const left = pool.filter(i => !usedWordsHistory.has(i.w)).length;
      document.getElementById('stat').textContent = `–°–ª–æ–≤ –Ω–∞ –ø–æ–ª–µ: ${placed.length} | –û—Å—Ç–∞–ª–æ—Å—å –≤ –±–∞–∑–µ: ${left}/${pool.length}`;
      
      if(document.getElementById('sidebar').classList.contains('collapsed')) {
        document.getElementById('sidebar').classList.remove('collapsed');
      }
    });
}

function onGenerate() {
  if (!crosswordHasProgress()) {
    onGenerateCore();
    return;
  }

  showConfirmPopup(
    '–°–±—Ä–æ—Å–∏—Ç—å —Ç–µ–∫—É—â–∏–π –∫—Ä–æ—Å—Å–≤–æ—Ä–¥ –∏ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –Ω–æ–≤—ã–π?',
    () => onGenerateCore(),
    () => {}
  );
}


  // –î–ª—è –≤–≤–æ–¥–∞ –±–µ–∑ –ø—Ä—ã–∂–∫–æ–≤ —ç–∫—Ä–∞–Ω–∞
  let keyBuffer = '';

    document.getElementById('cv').addEventListener('pointerdown', e => {
    if(isSolved || !window.lastG) return;
    
    const rect = e.target.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (e.target.width / rect.width);
    const y = (e.clientY - rect.top) * (e.target.height / rect.height);

    // –í—ã—á–∏—Å–ª—è–µ–º –º–∞—Å—à—Ç–∞–± –∏ —Å–º–µ—â–µ–Ω–∏–µ –∫–∞–∫ –≤ drawCrossword
    const targetSize = window.innerWidth <= 650 ? 380 : 600;
    const rs = [], cs = [];
    for(let r=0; r<N; r++) for(let c=0; c<N; c++) if(window.lastG[r][c]!=='.') { rs.push(r); cs.push(c); }
    
    const rMin = Math.max(0, Math.min(...rs) - 1);
    const cMin = Math.max(0, Math.min(...cs) - 1);
    const rMax = Math.min(N - 1, Math.max(...rs) + 1);
    const cMax = Math.min(N - 1, Math.max(...cs) + 1);
    
    const gridWidth = (cMax - cMin + 1) * CELL;
    const gridHeight = (rMax - rMin + 1) * CELL;
    const maxDim = Math.max(gridWidth, gridHeight);
    const availableSpace = targetSize - GPAD * 2 - 20;
    const scale = Math.min(1, availableSpace / maxDim);
    
    const offsetX = (targetSize - gridWidth * scale) / 2;
    const offsetY = (targetSize - gridHeight * scale) / 2;

    // –û–±—Ä–∞—Ç–Ω—ã–π —Ä–∞—Å—á—ë—Ç
    const gridX = (x - offsetX) / scale;
    const gridY = (y - offsetY) / scale;

    const c = Math.floor(gridX / CELL) + cMin;
    const r = Math.floor(gridY / CELL) + rMin;

    if(r>=0 && r<N && c>=0 && c<N && window.lastG[r][c]!=='.') {
      const words = window.lastPlaced.filter(p => 
        p.dir==='H' ? (p.r===r && c>=p.c && c<p.c+p.w.length) : 
        (p.c===c && r>=p.r && r<p.r+p.w.length)
      );
      
      if(words.length) {
        let selectedWord = words.find(w => (w.dir==='H' && w.r===r && w.c===c) || (w.dir==='V' && w.c===c && w.r===r));
        
        if(!selectedWord) {
          if(activeWord && words.includes(activeWord) && words.length > 1) {
            selectedWord = words.find(w => w !== activeWord);
          } else {
            selectedWord = words[0];
          }
        }
        
        activeWord = selectedWord;
        activeR = r; 
        activeC = c;
      } else { 
        activeWord = null; 
        activeR = -1; 
        activeC = -1; 
      }
    } else { 
      activeWord = null; 
      activeR = -1; 
      activeC = -1; 
    }
    
    updateUI(); 
    drawCrossword(window.lastG, window.lastPlaced);
});


  function handleInput(key) {
    if(!activeWord || isSolved) return;
    if(key==='Backspace') {
      userGrid[activeR][activeC]='';
      if(activeWord.dir==='H' && activeC>activeWord.c) activeC--; else if(activeWord.dir==='V' && activeR>activeWord.r) activeR--;
    } else if(key.length===1 && /[–∞-—è—ëa-z]/i.test(key)) {
      userGrid[activeR][activeC] = key.toUpperCase();
      if(activeWord.dir==='H' && activeC<activeWord.c+activeWord.w.length-1) activeC++;
      else if(activeWord.dir==='V' && activeR<activeWord.r+activeWord.w.length-1) activeR++;
      checkWin();
    }
    drawCrossword(window.lastG, window.lastPlaced);
  }

  // –ì–ª–æ–±–∞–ª—å–Ω—ã–π –ø–µ—Ä–µ—Ö–≤–∞—Ç –Ω–∞–∂–∞—Ç–∏–π (–±–µ–∑ focus-–∏–Ω–ø—É—Ç–∞)
  window.addEventListener('keydown', e => {
    if (e.target && e.target.id === 'hidden-input') return;
    if (e.target.id === 'hidden-input') return; // –º–æ–±–∏–ª—å–Ω—ã–π –≤–≤–æ–¥ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è —á–µ—Ä–µ–∑ input-—Å–æ–±—ã—Ç–∏–µ
    if (activeWord && !isSolved) {
      // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º —Å–ø–µ—Ü–∫–ª–∞–≤–∏—à–∏ –±—Ä–∞—É–∑–µ—Ä–∞, —á—Ç–æ–±—ã –Ω–µ –ø–µ—Ä–µ—Ö–≤–∞—Ç—ã–≤–∞—Ç—å –≤—Å—ë –ø–æ–¥—Ä—è–¥
      if (e.ctrlKey || e.altKey || e.metaKey) return;
      if (/[–∞-—è—ëa-z]/i.test(e.key) && e.key.length === 1) {
        handleInput(e.key);
      } else if (e.key === 'Backspace') {
        handleInput('Backspace');
      }
    }
  });

  function onToggleAnswers() {
    if(!window.lastG) return; showAnswers = !showAnswers;
    document.getElementById('btn-answ').textContent = showAnswers ? 'üîí –°–∫—Ä—ã—Ç—å' : 'üëÅ –û—Ç–≤–µ—Ç—ã';
    drawCrossword(window.lastG, window.lastPlaced);
  }

  function onExport() {
    const a = document.createElement('a'); a.download = 'crossword.png';
    a.href = document.getElementById('cv').toDataURL('image/png'); a.click();
  }

  // –ï–¥–∏–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ —Å–∫—Ä—ã—Ç–æ–π –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã –¥–ª—è –≤—Å–µ—Ö —Ä–µ–∂–∏–º–æ–≤
const hiddenInput = document.getElementById('hidden-input');

hiddenInput.addEventListener('input', (e) => {
  const char = e.data; // –¢–æ, —á—Ç–æ –≤–≤–µ–ª–∏
  hiddenInput.value = ''; // –°—Ä–∞–∑—É –æ—á–∏—â–∞–µ–º, —á—Ç–æ–±—ã –ª–æ–≤–∏—Ç—å —Å–ª–µ–¥—É—é—â–∏–π —Å–∏–º–≤–æ–ª

  // –ï—Å–ª–∏ –∞–∫—Ç–∏–≤–µ–Ω –ö—Ä–æ—Å—Å–≤–æ—Ä–¥
  if (document.getElementById('sec-crossword').classList.contains('active') && activeWord) {
    if (char && /[–∞-—è—ëa-z]/i.test(char)) handleInput(char);
  }
  
  // –ï—Å–ª–∏ –∞–∫—Ç–∏–≤–Ω–æ –°—É–¥–æ–∫—É
  if (document.getElementById('sec-sudoku').classList.contains('active')) {
    if (char && /[1-9]/.test(char)) sudokuInput(parseInt(char));
    if (char === '0') sudokuInput(0);
  }
});

// –õ–æ–≤–∏–º Backspace (–æ–Ω –Ω–µ –≤—ã–∑—ã–≤–∞–µ—Ç —Å–æ–±—ã—Ç–∏–µ input)
hiddenInput.addEventListener('keydown', (e) => {
  if (e.key === 'Backspace') {
    if (document.getElementById('sec-crossword').classList.contains('active')) handleInput('Backspace');
    if (document.getElementById('sec-sudoku').classList.contains('active')) sudokuInput(0);
  }
});

  window.onload = () => {
  onGenerate();     // –∫—Ä–æ—Å—Å–≤–æ—Ä–¥ –∫–∞–∫ —Ä–∞–Ω—å—à–µ
  philInitOnce();   // –ø–æ–¥–≥–æ—Ç–æ–≤–∏—Ç—å –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ (–±–µ–∑ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏)
  sudokuInitOnce(); // –°—É–¥–æ–∫—É
};
  </script>

  <script>
  // –û—Ç–∫–ª—é—á–∞–µ–º –ø—Ä–∞–≤—ã–π –∫–ª–∏–∫
  document.addEventListener('contextmenu', event => event.preventDefault());
  // –û—Ç–∫–ª—é—á–∞–µ–º F12 –∏ Ctrl+Shift+I
  document.onkeydown = function(e) {
    if(e.keyCode == 123) return false;
    if(e.ctrlKey && e.shiftKey && e.keyCode == 'I'.charCodeAt(0)) return false;
    if(e.ctrlKey && e.shiftKey && e.keyCode == 'C'.charCodeAt(0)) return false;
    if(e.ctrlKey && e.shiftKey && e.keyCode == 'J'.charCodeAt(0)) return false;
    if(e.ctrlKey && e.keyCode == 'U'.charCodeAt(0)) return false;
  }

  (function initSidebarSync() {
  const PAIRS = [
    { cvId: 'cv',     sbId: 'sidebar' },
    { cvId: 'cvPhil', sbId: 'philSidebar' }
  ];

  function syncOne(cvId, sbId) {
    if (window.innerWidth < 1280) return;
    const cv = document.getElementById(cvId);
    const sb = document.getElementById(sbId);
    if (!cv || !sb) return;
    if (!cv.offsetParent) return; // hidden tab ‚Äî –ø—Ä–æ–ø—É—Å–∫–∞–µ–º

    const h = cv.offsetHeight;
    if (h < 10) return; // canvas –µ—â—ë –Ω–µ –Ω–∞—Ä–∏—Å–æ–≤–∞–Ω

    const parentRect = sb.parentElement.getBoundingClientRect();
    const cvRect    = cv.getBoundingClientRect();
    const top = cvRect.top - parentRect.top;

    sb.style.top = top + 'px';
    // –≤—ã—Å–æ—Ç—É —Å—Ç–∞–≤–∏–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –Ω–µ —Å–≤—ë—Ä–Ω—É—Ç –≤ –∫—Ä—É–∂–æ–∫
    if (!sb.classList.contains('collapsed')) {
      sb.style.height = h + 'px';
    }
  }

  function syncAll() {
    PAIRS.forEach(p => syncOne(p.cvId, p.sbId));
  }

  // 1) –°–ª–µ–¥–∏–º –∑–∞ –∏–∑–º–µ–Ω–µ–Ω–∏–µ–º —Ä–∞–∑–º–µ—Ä–∞ canvas (–≥–µ–Ω–µ—Ä–∞—Ü–∏—è/—Ä–µ—Å–∞–π–∑)
  const ro = new ResizeObserver(entries => {
    entries.forEach(e => {
      const pair = PAIRS.find(p => p.cvId === e.target.id);
      if (pair) requestAnimationFrame(() => syncOne(pair.cvId, pair.sbId));
    });
  });
  PAIRS.forEach(p => {
    const cv = document.getElementById(p.cvId);
    if (cv) ro.observe(cv);
  });

  // 2) –°–ª–µ–¥–∏–º –∑–∞ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ–º –≤–∫–ª–∞–¥–æ–∫ (–ø–æ—è–≤–ª–µ–Ω–∏–µ –∫–ª–∞—Å—Å–∞ .active)
  const mo = new MutationObserver(mutations => {
    mutations.forEach(m => {
      if (m.target.classList.contains('active')) {
        // –¥–≤–æ–π–Ω–æ–π rAF ‚Äî –∂–¥—ë–º –ø–æ–ª–Ω—ã–π layout flush
        requestAnimationFrame(() => requestAnimationFrame(syncAll));
      }
    });
  });
  document.querySelectorAll('.game-section').forEach(s => {
    mo.observe(s, { attributes: true, attributeFilter: ['class'] });
  });

  // 3) –†–µ—Å–∞–π–∑ –æ–∫–Ω–∞
  window.addEventListener('resize', () => requestAnimationFrame(syncAll));

  // 4) –ù–∞—á–∞–ª—å–Ω–∞—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è
  setTimeout(syncAll, 300);

  // 5) –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º –¥–ª—è –≤—ã–∑–æ–≤–∞ –ø–æ—Å–ª–µ toggleSidebar()
  window.syncSidebars = syncAll;
})();

// ==========================================
// –ê–í–¢–û-–ü–û–î–ì–û–ù–ö–ê –í–´–°–û–¢–´ –°–ü–ò–°–ö–ê –ü–û–î –°–ï–¢–ö–£
// ==========================================
const resizeObserver = new ResizeObserver(entries => {
  // –ï—Å–ª–∏ –º—ã –Ω–µ –Ω–∞ –ü–ö (—à–∏—Ä–∏–Ω–∞ –º–µ–Ω—å—à–µ 1280), –Ω–∏—á–µ–≥–æ –Ω–µ –¥–µ–ª–∞–µ–º, —Ç–∞–º —Å—Ç–∏–ª–∏ —Ä–∞–±–æ—Ç–∞—é—Ç —Å–∞–º–∏
  if (window.innerWidth < 1280) {
     document.getElementById('sidebar').style.height = '';
     document.getElementById('philSidebar').style.height = '';
     return;
  }

  for (let entry of entries) {
    const height = entry.contentRect.height;
    
    // 72 ‚Äî —ç—Ç–æ —Ç–æ—Ç —Å–∞–º—ã–π –æ—Ç—Å—Ç—É–ø top: 72px –∏–∑ CSS.
    // –ú—ã –≤—ã—á–∏—Ç–∞–µ–º –µ–≥–æ, —á—Ç–æ–±—ã –Ω–∏–∑ —Å–ø–∏—Å–∫–∞ —Å–æ–≤–ø–∞–ª —Å –Ω–∏–∑–æ–º —Å–µ—Ç–∫–∏.
    // –ï—Å–ª–∏ —Å–ø–∏—Å–æ–∫ –∫–∞–∂–µ—Ç—Å—è –∫–æ—Ä–æ—Ç–∫–∏–º, —É–º–µ–Ω—å—à–∏ 72. –ï—Å–ª–∏ –¥–ª–∏–Ω–Ω—ã–º ‚Äî —É–≤–µ–ª–∏—á—å.
    const sidebarHeight = height - 72; 

    if (entry.target.id === 'cv') {
       const sb = document.getElementById('sidebar');
       if (sb) sb.style.height = sidebarHeight + 'px';
    }
    
    if (entry.target.id === 'cvPhil') {
       const sb = document.getElementById('philSidebar');
       if (sb) sb.style.height = sidebarHeight + 'px';
    }
  }
});

// –ù–∞—á–∏–Ω–∞–µ–º —Å–ª–µ–¥–∏—Ç—å –∑–∞ –æ–±–æ–∏–º–∏ —Ö–æ–ª—Å—Ç–∞–º–∏
setTimeout(() => {
  const cv1 = document.getElementById('cv');
  const cv2 = document.getElementById('cvPhil');
  if (cv1) resizeObserver.observe(cv1);
  if (cv2) resizeObserver.observe(cv2);
}, 500); // –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞, —á—Ç–æ–±—ã —ç–ª–µ–º–µ–Ω—Ç—ã —Ç–æ—á–Ω–æ –ø—Ä–æ–≥—Ä—É–∑–∏–ª–∏—Å—å

</script>

</body>
</html>
